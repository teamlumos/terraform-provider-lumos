// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package provider

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/objectplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	speakeasy_boolplanmodifier "github.com/teamlumos/terraform-provider-lumos/internal/planmodifiers/boolplanmodifier"
	speakeasy_listplanmodifier "github.com/teamlumos/terraform-provider-lumos/internal/planmodifiers/listplanmodifier"
	speakeasy_objectplanmodifier "github.com/teamlumos/terraform-provider-lumos/internal/planmodifiers/objectplanmodifier"
	speakeasy_setplanmodifier "github.com/teamlumos/terraform-provider-lumos/internal/planmodifiers/setplanmodifier"
	speakeasy_stringplanmodifier "github.com/teamlumos/terraform-provider-lumos/internal/planmodifiers/stringplanmodifier"
	tfTypes "github.com/teamlumos/terraform-provider-lumos/internal/provider/types"
	"github.com/teamlumos/terraform-provider-lumos/internal/sdk"
	"github.com/teamlumos/terraform-provider-lumos/internal/sdk/models/operations"
	custom_objectvalidators "github.com/teamlumos/terraform-provider-lumos/internal/validators/objectvalidators"
	speakeasy_objectvalidators "github.com/teamlumos/terraform-provider-lumos/internal/validators/objectvalidators"
	speakeasy_stringvalidators "github.com/teamlumos/terraform-provider-lumos/internal/validators/stringvalidators"
)

// Ensure provider defined types fully satisfy framework interfaces.
var _ resource.Resource = &RequestablePermissionResource{}
var _ resource.ResourceWithImportState = &RequestablePermissionResource{}

func NewRequestablePermissionResource() resource.Resource {
	return &RequestablePermissionResource{}
}

// RequestablePermissionResource defines the resource implementation.
type RequestablePermissionResource struct {
	client *sdk.Lumos
}

// RequestablePermissionResourceModel describes the resource data model.
type RequestablePermissionResourceModel struct {
	AppClassID    types.String                                     `tfsdk:"app_class_id"`
	AppID         types.String                                     `tfsdk:"app_id"`
	AppInstanceID types.String                                     `tfsdk:"app_instance_id"`
	ID            types.String                                     `tfsdk:"id"`
	Label         types.String                                     `tfsdk:"label"`
	RequestConfig *tfTypes.RequestablePermissionInputRequestConfig `tfsdk:"request_config"`
	Type          types.String                                     `tfsdk:"type"`
}

func (r *RequestablePermissionResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_requestable_permission"
}

func (r *RequestablePermissionResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		MarkdownDescription: "RequestablePermission Resource",
		Attributes: map[string]schema.Attribute{
			"app_class_id": schema.StringAttribute{
				Computed: true,
				Optional: true,
				PlanModifiers: []planmodifier.String{
					speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
				},
				Description: `The ID of the service associated with this requestable permission.`,
			},
			"app_id": schema.StringAttribute{
				Required:    true,
				Description: `The ID of the app associated with this requestable permission.`,
			},
			"app_instance_id": schema.StringAttribute{
				Computed: true,
				Optional: true,
				PlanModifiers: []planmodifier.String{
					speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
				},
				Description: `Optionally, an app has an identifer associated with it's particular instance.`,
			},
			"id": schema.StringAttribute{
				Computed: true,
				PlanModifiers: []planmodifier.String{
					speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
				},
				Description: `The ID of this requestable permission.`,
			},
			"label": schema.StringAttribute{
				Required:    true,
				Description: `The label of this requestable permission.`,
			},
			"request_config": schema.SingleNestedAttribute{
				Computed: true,
				Optional: true,
				PlanModifiers: []planmodifier.Object{
					speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
				},
				Attributes: map[string]schema.Attribute{
					"access_removal_inline_webhook": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Attributes: map[string]schema.Attribute{
							"description": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `The description of this inline webhook.`,
							},
							"hook_type": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `The type of this inline webhook. must be one of ["PRE_APPROVAL", "PROVISION", "DEPROVISION", "REQUEST_VALIDATION", "SIEM"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"PRE_APPROVAL",
										"PROVISION",
										"DEPROVISION",
										"REQUEST_VALIDATION",
										"SIEM",
									),
								},
							},
							"id": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `The ID of this inline webhook. Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"name": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `The name of this inline webhook.`,
							},
						},
						Description: `A deprovisioning webhook can be optionally associated with this config.`,
					},
					"allowed_groups": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Attributes: map[string]schema.Attribute{
							"groups": schema.SetNestedAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.Set{
									speakeasy_setplanmodifier.SuppressDiff(speakeasy_setplanmodifier.ExplicitSuppress),
								},
								NestedObject: schema.NestedAttributeObject{
									Validators: []validator.Object{
										speakeasy_objectvalidators.NotNull(),
									},
									PlanModifiers: []planmodifier.Object{
										speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
									},
									Attributes: map[string]schema.Attribute{
										"app_id": schema.StringAttribute{
											Computed: true,
											Optional: true,
											PlanModifiers: []planmodifier.String{
												speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
											},
											Description: `The ID of the app that sources this group.`,
										},
										"description": schema.StringAttribute{
											Computed: true,
											PlanModifiers: []planmodifier.String{
												speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
											},
											Description: `The description of this group.`,
										},
										"group_lifecycle": schema.StringAttribute{
											Computed: true,
											Default:  stringdefault.StaticString("SYNCED"),
											PlanModifiers: []planmodifier.String{
												speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
											},
											Description: `The lifecycle of this group. Default: "SYNCED"; must be one of ["SYNCED", "NATIVE"]`,
											Validators: []validator.String{
												stringvalidator.OneOf(
													"SYNCED",
													"NATIVE",
												),
											},
										},
										"id": schema.StringAttribute{
											Computed: true,
											Optional: true,
											PlanModifiers: []planmodifier.String{
												speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
											},
											Description: `The ID of this group.`,
										},
										"integration_specific_id": schema.StringAttribute{
											Computed: true,
											Optional: true,
											PlanModifiers: []planmodifier.String{
												speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
											},
											Description: `The ID of this group, specific to the integration.`,
										},
										"name": schema.StringAttribute{
											Computed: true,
											PlanModifiers: []planmodifier.String{
												speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
											},
											Description: `The name of this group.`,
										},
										"source_app_id": schema.StringAttribute{
											Computed: true,
											PlanModifiers: []planmodifier.String{
												speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
											},
											Description: `The ID of the app that sources this group.`,
										},
									},
								},
								Description: `The groups allowed to request this permission.`,
							},
							"type": schema.StringAttribute{
								Computed: true,
								Optional: true,
								Default:  stringdefault.StaticString("ALL_GROUPS"),
								PlanModifiers: []planmodifier.String{
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `The type of this allowed groups config, can be all groups or specific. Default: "ALL_GROUPS"; must be one of ["ALL_GROUPS", "SPECIFIED_GROUPS"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"ALL_GROUPS",
										"SPECIFIED_GROUPS",
									),
								},
							},
						},
						Description: `Refers to which group(s) can make requests to this permission.`,
					},
					"allowed_groups_override": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Bool{
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Indicates if allowed groups is overriden from the app-level settings.`,
					},
					"appstore_visibility": schema.StringAttribute{
						Computed: true,
						Optional: true,
						Default:  stringdefault.StaticString("HIDDEN"),
						PlanModifiers: []planmodifier.String{
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `The appstore visibility of this request config. Default: "HIDDEN"; must be one of ["HIDDEN", "VISIBLE"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"HIDDEN",
								"VISIBLE",
							),
						},
					},
					"request_approval_config": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Attributes: map[string]schema.Attribute{
							"approvers": schema.SingleNestedAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.Object{
									speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
								},
								Attributes: map[string]schema.Attribute{
									"groups": schema.SetNestedAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.Set{
											speakeasy_setplanmodifier.SuppressDiff(speakeasy_setplanmodifier.ExplicitSuppress),
										},
										NestedObject: schema.NestedAttributeObject{
											Validators: []validator.Object{
												speakeasy_objectvalidators.NotNull(),
											},
											PlanModifiers: []planmodifier.Object{
												speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
											},
											Attributes: map[string]schema.Attribute{
												"app_id": schema.StringAttribute{
													Computed: true,
													Optional: true,
													PlanModifiers: []planmodifier.String{
														speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
													},
													Description: `The ID of the app that sources this group.`,
												},
												"description": schema.StringAttribute{
													Computed: true,
													PlanModifiers: []planmodifier.String{
														speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
													},
													Description: `The description of this group.`,
												},
												"group_lifecycle": schema.StringAttribute{
													Computed: true,
													Default:  stringdefault.StaticString("SYNCED"),
													PlanModifiers: []planmodifier.String{
														speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
													},
													Description: `The lifecycle of this group. Default: "SYNCED"; must be one of ["SYNCED", "NATIVE"]`,
													Validators: []validator.String{
														stringvalidator.OneOf(
															"SYNCED",
															"NATIVE",
														),
													},
												},
												"id": schema.StringAttribute{
													Computed: true,
													Optional: true,
													PlanModifiers: []planmodifier.String{
														speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
													},
													Description: `The ID of this group.`,
												},
												"integration_specific_id": schema.StringAttribute{
													Computed: true,
													Optional: true,
													PlanModifiers: []planmodifier.String{
														speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
													},
													Description: `The ID of this group, specific to the integration.`,
												},
												"name": schema.StringAttribute{
													Computed: true,
													PlanModifiers: []planmodifier.String{
														speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
													},
													Description: `The name of this group.`,
												},
												"source_app_id": schema.StringAttribute{
													Computed: true,
													PlanModifiers: []planmodifier.String{
														speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
													},
													Description: `The ID of the app that sources this group.`,
												},
											},
										},
										Description: `Groups assigned as support request approvers.`,
									},
									"users": schema.SetNestedAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.Set{
											speakeasy_setplanmodifier.SuppressDiff(speakeasy_setplanmodifier.ExplicitSuppress),
										},
										NestedObject: schema.NestedAttributeObject{
											Validators: []validator.Object{
												speakeasy_objectvalidators.NotNull(),
											},
											PlanModifiers: []planmodifier.Object{
												speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
											},
											Attributes: map[string]schema.Attribute{
												"email": schema.StringAttribute{
													Computed: true,
													PlanModifiers: []planmodifier.String{
														speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
													},
													Description: `The email of this user.`,
												},
												"family_name": schema.StringAttribute{
													Computed: true,
													PlanModifiers: []planmodifier.String{
														speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
													},
													Description: `The family name of this user.`,
												},
												"given_name": schema.StringAttribute{
													Computed: true,
													PlanModifiers: []planmodifier.String{
														speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
													},
													Description: `The given name of this user.`,
												},
												"id": schema.StringAttribute{
													Computed: true,
													Optional: true,
													PlanModifiers: []planmodifier.String{
														speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
													},
													Description: `The ID of this user. Not Null`,
													Validators: []validator.String{
														speakeasy_stringvalidators.NotNull(),
													},
												},
												"status": schema.StringAttribute{
													Computed: true,
													PlanModifiers: []planmodifier.String{
														speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
													},
													Description: `The status of this user. must be one of ["STAGED", "ACTIVE", "SUSPENDED", "INACTIVE"]`,
													Validators: []validator.String{
														stringvalidator.OneOf(
															"STAGED",
															"ACTIVE",
															"SUSPENDED",
															"INACTIVE",
														),
													},
												},
											},
										},
										Description: `Users assigned as support request approvers.`,
									},
								},
								Description: `AppStore App approvers assigned.`,
							},
							"approvers_stage_2": schema.SingleNestedAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.Object{
									speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
								},
								Attributes: map[string]schema.Attribute{
									"groups": schema.SetNestedAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.Set{
											speakeasy_setplanmodifier.SuppressDiff(speakeasy_setplanmodifier.ExplicitSuppress),
										},
										NestedObject: schema.NestedAttributeObject{
											Validators: []validator.Object{
												speakeasy_objectvalidators.NotNull(),
											},
											PlanModifiers: []planmodifier.Object{
												speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
											},
											Attributes: map[string]schema.Attribute{
												"app_id": schema.StringAttribute{
													Computed: true,
													Optional: true,
													PlanModifiers: []planmodifier.String{
														speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
													},
													Description: `The ID of the app that sources this group.`,
												},
												"description": schema.StringAttribute{
													Computed: true,
													PlanModifiers: []planmodifier.String{
														speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
													},
													Description: `The description of this group.`,
												},
												"group_lifecycle": schema.StringAttribute{
													Computed: true,
													Default:  stringdefault.StaticString("SYNCED"),
													PlanModifiers: []planmodifier.String{
														speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
													},
													Description: `The lifecycle of this group. Default: "SYNCED"; must be one of ["SYNCED", "NATIVE"]`,
													Validators: []validator.String{
														stringvalidator.OneOf(
															"SYNCED",
															"NATIVE",
														),
													},
												},
												"id": schema.StringAttribute{
													Computed: true,
													Optional: true,
													PlanModifiers: []planmodifier.String{
														speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
													},
													Description: `The ID of this group.`,
												},
												"integration_specific_id": schema.StringAttribute{
													Computed: true,
													Optional: true,
													PlanModifiers: []planmodifier.String{
														speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
													},
													Description: `The ID of this group, specific to the integration.`,
												},
												"name": schema.StringAttribute{
													Computed: true,
													PlanModifiers: []planmodifier.String{
														speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
													},
													Description: `The name of this group.`,
												},
												"source_app_id": schema.StringAttribute{
													Computed: true,
													PlanModifiers: []planmodifier.String{
														speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
													},
													Description: `The ID of the app that sources this group.`,
												},
											},
										},
										Description: `Groups assigned as support request approvers.`,
									},
									"users": schema.SetNestedAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.Set{
											speakeasy_setplanmodifier.SuppressDiff(speakeasy_setplanmodifier.ExplicitSuppress),
										},
										NestedObject: schema.NestedAttributeObject{
											Validators: []validator.Object{
												speakeasy_objectvalidators.NotNull(),
											},
											PlanModifiers: []planmodifier.Object{
												speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
											},
											Attributes: map[string]schema.Attribute{
												"email": schema.StringAttribute{
													Computed: true,
													PlanModifiers: []planmodifier.String{
														speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
													},
													Description: `The email of this user.`,
												},
												"family_name": schema.StringAttribute{
													Computed: true,
													PlanModifiers: []planmodifier.String{
														speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
													},
													Description: `The family name of this user.`,
												},
												"given_name": schema.StringAttribute{
													Computed: true,
													PlanModifiers: []planmodifier.String{
														speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
													},
													Description: `The given name of this user.`,
												},
												"id": schema.StringAttribute{
													Computed: true,
													Optional: true,
													PlanModifiers: []planmodifier.String{
														speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
													},
													Description: `The ID of this user. Not Null`,
													Validators: []validator.String{
														speakeasy_stringvalidators.NotNull(),
													},
												},
												"status": schema.StringAttribute{
													Computed: true,
													PlanModifiers: []planmodifier.String{
														speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
													},
													Description: `The status of this user. must be one of ["STAGED", "ACTIVE", "SUSPENDED", "INACTIVE"]`,
													Validators: []validator.String{
														stringvalidator.OneOf(
															"STAGED",
															"ACTIVE",
															"SUSPENDED",
															"INACTIVE",
														),
													},
												},
											},
										},
										Description: `Users assigned as support request approvers.`,
									},
								},
								Description: `AppStore App stage 2 approvers assigned.`,
							},
							"custom_approval_message": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `After the approval step, send a custom message to requesters. Note that the permission level approval message will override the App level approval message if custom_approval_message_override is set. Markdown for links and text formatting is supported.`,
							},
							"custom_approval_message_override": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.Bool{
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								Description: `Indicates if custom_approval_message is overridden.`,
							},
							"manager_approval": schema.StringAttribute{
								Computed: true,
								Optional: true,
								Default:  stringdefault.StaticString("NONE"),
								PlanModifiers: []planmodifier.String{
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `Manager approval can be configured as necessary to continue. Default: "NONE"; must be one of ["NONE", "INITIAL_APPROVAL"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"NONE",
										"INITIAL_APPROVAL",
									),
								},
							},
							"request_approval_config_override": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.Bool{
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								Description: `Indicates if approval flow is overridden.`,
							},
							"require_additional_approval": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.Bool{
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								Description: `Only turn on when working with sensitive permissions to ensure a smooth employee experience.`,
							},
						},
						Description: `A request approval config can be optionally associated with this config`,
					},
					"request_fulfillment_config": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Attributes: map[string]schema.Attribute{
							"manual_instructions": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `The manual instructions that go along.`,
							},
							"manual_steps_needed": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.Bool{
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								Description: `Whether manual steps are needed.`,
							},
							"provisioning_group": schema.SingleNestedAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.Object{
									objectplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
								},
								Attributes: map[string]schema.Attribute{
									"app_id": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											stringplanmodifier.RequiresReplaceIfConfigured(),
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `The ID of the app that sources this group. Requires replacement if changed.`,
									},
									"description": schema.StringAttribute{
										Computed: true,
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `The description of this group.`,
									},
									"group_lifecycle": schema.StringAttribute{
										Computed: true,
										Default:  stringdefault.StaticString("SYNCED"),
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `The lifecycle of this group. Default: "SYNCED"; must be one of ["SYNCED", "NATIVE"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"SYNCED",
												"NATIVE",
											),
										},
									},
									"id": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											stringplanmodifier.RequiresReplaceIfConfigured(),
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `The ID of this group. Requires replacement if changed.`,
									},
									"integration_specific_id": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											stringplanmodifier.RequiresReplaceIfConfigured(),
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `The ID of this group, specific to the integration. Requires replacement if changed.`,
									},
									"name": schema.StringAttribute{
										Computed: true,
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `The name of this group.`,
									},
									"source_app_id": schema.StringAttribute{
										Computed: true,
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `The ID of the app that sources this group.`,
									},
								},
								Description: `The provisioning group optionally associated with this config. Requires replacement if changed.`,
							},
							"provisioning_webhook": schema.SingleNestedAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.Object{
									speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
								},
								Attributes: map[string]schema.Attribute{
									"description": schema.StringAttribute{
										Computed: true,
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `The description of this inline webhook.`,
									},
									"hook_type": schema.StringAttribute{
										Computed: true,
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `The type of this inline webhook. must be one of ["PRE_APPROVAL", "PROVISION", "DEPROVISION", "REQUEST_VALIDATION", "SIEM"]`,
										Validators: []validator.String{
											stringvalidator.OneOf(
												"PRE_APPROVAL",
												"PROVISION",
												"DEPROVISION",
												"REQUEST_VALIDATION",
												"SIEM",
											),
										},
									},
									"id": schema.StringAttribute{
										Computed: true,
										Optional: true,
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `The ID of this inline webhook. Not Null`,
										Validators: []validator.String{
											speakeasy_stringvalidators.NotNull(),
										},
									},
									"name": schema.StringAttribute{
										Computed: true,
										PlanModifiers: []planmodifier.String{
											speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
										},
										Description: `The name of this inline webhook.`,
									},
								},
								Description: `The provisioning webhook optionally associated with this config.`,
							},
							"time_based_access": schema.ListAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.List{
									speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
								},
								ElementType: types.StringType,
								Description: `If enabled, users can request an app for a selected duration. After expiry, Lumos will automatically remove user's access.`,
							},
							"time_based_access_override": schema.BoolAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.Bool{
									speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
								},
								Description: `Indicates if time based access is overriden.`,
							},
						},
						Description: `A request fulfillment config can be optionally associated with this config`,
					},
					"request_validation_inline_webhook": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Attributes: map[string]schema.Attribute{
							"description": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `The description of this inline webhook.`,
							},
							"hook_type": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `The type of this inline webhook. must be one of ["PRE_APPROVAL", "PROVISION", "DEPROVISION", "REQUEST_VALIDATION", "SIEM"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"PRE_APPROVAL",
										"PROVISION",
										"DEPROVISION",
										"REQUEST_VALIDATION",
										"SIEM",
									),
								},
							},
							"id": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `The ID of this inline webhook. Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"name": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `The name of this inline webhook.`,
							},
						},
						Description: `A request validation webhook can be optionally associated with this config.`,
					},
				},
				Description: `The request config associated with this requestable permission.`,
				Validators: []validator.Object{
					custom_objectvalidators.RequestConfigInputValidator(),
				},
			},
			"type": schema.StringAttribute{
				Computed: true,
				PlanModifiers: []planmodifier.String{
					speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
				},
				Description: `The type of this requestable permission. must be one of ["SYNCED", "NATIVE"]`,
				Validators: []validator.String{
					stringvalidator.OneOf(
						"SYNCED",
						"NATIVE",
					),
				},
			},
		},
	}
}

func (r *RequestablePermissionResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	// Prevent panic if the provider has not been configured.
	if req.ProviderData == nil {
		return
	}

	client, ok := req.ProviderData.(*sdk.Lumos)

	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *sdk.Lumos, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)

		return
	}

	r.client = client
}

func (r *RequestablePermissionResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data *RequestablePermissionResourceModel
	var plan types.Object

	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(plan.As(ctx, &data, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)

	if resp.Diagnostics.HasError() {
		return
	}

	request := *data.ToSharedRequestablePermissionInput()
	res, err := r.client.AppStore.CreateAppstoreRequestablePermissionAppstoreRequestablePermissionsPost(ctx, request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode != 201 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}
	if !(res.RequestablePermissionOutput != nil) {
		resp.Diagnostics.AddError("unexpected response from API. Got an unexpected response body", debugResponse(res.RawResponse))
		return
	}
	data.RefreshFromSharedRequestablePermissionOutput(res.RequestablePermissionOutput)
	refreshPlan(ctx, plan, &data, resp.Diagnostics)

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *RequestablePermissionResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data *RequestablePermissionResourceModel
	var item types.Object

	resp.Diagnostics.Append(req.State.Get(ctx, &item)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(item.As(ctx, &data, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)

	if resp.Diagnostics.HasError() {
		return
	}

	var id string
	id = data.ID.ValueString()

	request := operations.GetAppstorePermissionAppstoreRequestablePermissionsPermissionIDGetRequest{
		ID: id,
	}
	res, err := r.client.AppStore.GetAppstorePermissionAppstoreRequestablePermissionsPermissionIDGet(ctx, request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode == 404 {
		resp.State.RemoveResource(ctx)
		return
	}
	if res.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}
	if !(res.RequestablePermissionOutput != nil) {
		resp.Diagnostics.AddError("unexpected response from API. Got an unexpected response body", debugResponse(res.RawResponse))
		return
	}
	data.RefreshFromSharedRequestablePermissionOutput(res.RequestablePermissionOutput)

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *RequestablePermissionResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var data *RequestablePermissionResourceModel
	var plan types.Object

	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	merge(ctx, req, resp, &data)
	if resp.Diagnostics.HasError() {
		return
	}

	var id string
	id = data.ID.ValueString()

	requestablePermissionInputUpdate := *data.ToSharedRequestablePermissionInputUpdate()
	request := operations.UpdateAppstorePermissionAppstoreRequestablePermissionsPermissionIDPatchRequest{
		ID:                               id,
		RequestablePermissionInputUpdate: requestablePermissionInputUpdate,
	}
	res, err := r.client.AppStore.UpdateAppstorePermissionAppstoreRequestablePermissionsPermissionIDPatch(ctx, request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}
	if !(res.RequestablePermissionOutput != nil) {
		resp.Diagnostics.AddError("unexpected response from API. Got an unexpected response body", debugResponse(res.RawResponse))
		return
	}
	data.RefreshFromSharedRequestablePermissionOutput(res.RequestablePermissionOutput)
	refreshPlan(ctx, plan, &data, resp.Diagnostics)

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *RequestablePermissionResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data *RequestablePermissionResourceModel
	var item types.Object

	resp.Diagnostics.Append(req.State.Get(ctx, &item)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(item.As(ctx, &data, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)

	if resp.Diagnostics.HasError() {
		return
	}

	var id string
	id = data.ID.ValueString()

	request := operations.DeleteAppstorePermissionAppstoreRequestablePermissionsPermissionIDDeleteRequest{
		ID: id,
	}
	res, err := r.client.AppStore.DeleteAppstorePermissionAppstoreRequestablePermissionsPermissionIDDelete(ctx, request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode != 204 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}

}

func (r *RequestablePermissionResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("id"), req.ID)...)
}
