// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
// @generated-id: 08b666ec6393

package provider

import (
	"context"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	tfTypes "github.com/teamlumos/terraform-provider-lumos/internal/provider/types"
	"github.com/teamlumos/terraform-provider-lumos/internal/sdk/models/operations"
	"github.com/teamlumos/terraform-provider-lumos/internal/sdk/models/shared"
)

func (r *PreApprovalRuleResourceModel) RefreshFromSharedPreApprovalRuleOutput(ctx context.Context, resp *shared.PreApprovalRuleOutput) diag.Diagnostics {
	var diags diag.Diagnostics

	if resp != nil {
		r.AppClassID = types.StringValue(resp.AppClassID)
		r.AppID = types.StringValue(resp.AppID)
		r.AppInstanceID = types.StringValue(resp.AppInstanceID)
		r.ID = types.StringPointerValue(resp.ID)
		r.Justification = types.StringValue(resp.Justification)
		r.PreapprovalWebhooks = []tfTypes.BaseInlineWebhook{}

		for _, preapprovalWebhooksItem := range resp.PreapprovalWebhooks {
			var preapprovalWebhooks tfTypes.BaseInlineWebhook

			preapprovalWebhooks.Description = types.StringPointerValue(preapprovalWebhooksItem.Description)
			preapprovalWebhooks.HookType = types.StringValue(string(preapprovalWebhooksItem.HookType))
			preapprovalWebhooks.ID = types.StringValue(preapprovalWebhooksItem.ID)
			preapprovalWebhooks.Name = types.StringValue(preapprovalWebhooksItem.Name)

			r.PreapprovalWebhooks = append(r.PreapprovalWebhooks, preapprovalWebhooks)
		}
		r.PreapprovedGroups = []tfTypes.Group{}

		for _, preapprovedGroupsItem := range resp.PreapprovedGroups {
			var preapprovedGroups tfTypes.Group

			preapprovedGroups.AppID = types.StringPointerValue(preapprovedGroupsItem.AppID)
			preapprovedGroups.Description = types.StringPointerValue(preapprovedGroupsItem.Description)
			if preapprovedGroupsItem.GroupLifecycle != nil {
				preapprovedGroups.GroupLifecycle = types.StringValue(string(*preapprovedGroupsItem.GroupLifecycle))
			} else {
				preapprovedGroups.GroupLifecycle = types.StringNull()
			}
			preapprovedGroups.ID = types.StringPointerValue(preapprovedGroupsItem.ID)
			preapprovedGroups.IntegrationSpecificID = types.StringPointerValue(preapprovedGroupsItem.IntegrationSpecificID)
			preapprovedGroups.Name = types.StringPointerValue(preapprovedGroupsItem.Name)
			preapprovedGroups.SourceAppID = types.StringPointerValue(preapprovedGroupsItem.SourceAppID)

			r.PreapprovedGroups = append(r.PreapprovedGroups, preapprovedGroups)
		}
		r.PreapprovedPermissions = []tfTypes.RequestablePermissionBase{}

		for _, preapprovedPermissionsItem := range resp.PreapprovedPermissions {
			var preapprovedPermissions tfTypes.RequestablePermissionBase

			preapprovedPermissions.AppClassID = types.StringValue(preapprovedPermissionsItem.AppClassID)
			preapprovedPermissions.AppID = types.StringValue(preapprovedPermissionsItem.AppID)
			preapprovedPermissions.AppInstanceID = types.StringValue(preapprovedPermissionsItem.AppInstanceID)
			preapprovedPermissions.ID = types.StringPointerValue(preapprovedPermissionsItem.ID)
			preapprovedPermissions.Label = types.StringValue(preapprovedPermissionsItem.Label)
			if preapprovedPermissionsItem.Type != nil {
				preapprovedPermissions.Type = types.StringValue(string(*preapprovedPermissionsItem.Type))
			} else {
				preapprovedPermissions.Type = types.StringNull()
			}

			r.PreapprovedPermissions = append(r.PreapprovedPermissions, preapprovedPermissions)
		}
		r.PreapprovedUsersByAttribute = []tfTypes.AttributeEqualityRule{}

		for _, preapprovedUsersByAttributeItem := range resp.PreapprovedUsersByAttribute {
			var preapprovedUsersByAttribute tfTypes.AttributeEqualityRule

			preapprovedUsersByAttribute.Attribute = types.StringValue(preapprovedUsersByAttributeItem.Attribute)
			preapprovedUsersByAttribute.Value = types.StringValue(preapprovedUsersByAttributeItem.Value)

			r.PreapprovedUsersByAttribute = append(r.PreapprovedUsersByAttribute, preapprovedUsersByAttribute)
		}
		r.TimeBasedAccess = make([]types.String, 0, len(resp.TimeBasedAccess))
		for _, v := range resp.TimeBasedAccess {
			r.TimeBasedAccess = append(r.TimeBasedAccess, types.StringValue(string(v)))
		}
	}

	return diags
}

func (r *PreApprovalRuleResourceModel) ToOperationsDeletePreApprovalRuleAppstorePreApprovalRulesPreApprovalRuleIDDeleteRequest(ctx context.Context) (*operations.DeletePreApprovalRuleAppstorePreApprovalRulesPreApprovalRuleIDDeleteRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var id string
	id = r.ID.ValueString()

	out := operations.DeletePreApprovalRuleAppstorePreApprovalRulesPreApprovalRuleIDDeleteRequest{
		ID: id,
	}

	return &out, diags
}

func (r *PreApprovalRuleResourceModel) ToOperationsUpdatePreApprovalRuleAppstorePreApprovalRulesPreApprovalRuleIDPatchRequest(ctx context.Context) (*operations.UpdatePreApprovalRuleAppstorePreApprovalRulesPreApprovalRuleIDPatchRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var id string
	id = r.ID.ValueString()

	preApprovalRuleUpdateInput, preApprovalRuleUpdateInputDiags := r.ToSharedPreApprovalRuleUpdateInput(ctx)
	diags.Append(preApprovalRuleUpdateInputDiags...)

	if diags.HasError() {
		return nil, diags
	}

	out := operations.UpdatePreApprovalRuleAppstorePreApprovalRulesPreApprovalRuleIDPatchRequest{
		ID:                         id,
		PreApprovalRuleUpdateInput: *preApprovalRuleUpdateInput,
	}

	return &out, diags
}

func (r *PreApprovalRuleResourceModel) ToSharedPreApprovalRuleInput(ctx context.Context) (*shared.PreApprovalRuleInput, diag.Diagnostics) {
	var diags diag.Diagnostics

	var justification string
	justification = r.Justification.ValueString()

	timeBasedAccess := make([]shared.TimeBasedAccessOptions, 0, len(r.TimeBasedAccess))
	for _, timeBasedAccessItem := range r.TimeBasedAccess {
		timeBasedAccess = append(timeBasedAccess, shared.TimeBasedAccessOptions(timeBasedAccessItem.ValueString()))
	}
	var appID string
	appID = r.AppID.ValueString()

	preapprovedGroups := make([]shared.BaseGroup, 0, len(r.PreapprovedGroups))
	for preapprovedGroupsIndex := range r.PreapprovedGroups {
		id := new(string)
		if !r.PreapprovedGroups[preapprovedGroupsIndex].ID.IsUnknown() && !r.PreapprovedGroups[preapprovedGroupsIndex].ID.IsNull() {
			*id = r.PreapprovedGroups[preapprovedGroupsIndex].ID.ValueString()
		} else {
			id = nil
		}
		appId1 := new(string)
		if !r.PreapprovedGroups[preapprovedGroupsIndex].AppID.IsUnknown() && !r.PreapprovedGroups[preapprovedGroupsIndex].AppID.IsNull() {
			*appId1 = r.PreapprovedGroups[preapprovedGroupsIndex].AppID.ValueString()
		} else {
			appId1 = nil
		}
		integrationSpecificID := new(string)
		if !r.PreapprovedGroups[preapprovedGroupsIndex].IntegrationSpecificID.IsUnknown() && !r.PreapprovedGroups[preapprovedGroupsIndex].IntegrationSpecificID.IsNull() {
			*integrationSpecificID = r.PreapprovedGroups[preapprovedGroupsIndex].IntegrationSpecificID.ValueString()
		} else {
			integrationSpecificID = nil
		}
		preapprovedGroups = append(preapprovedGroups, shared.BaseGroup{
			ID:                    id,
			AppID:                 appId1,
			IntegrationSpecificID: integrationSpecificID,
		})
	}
	preapprovedPermissions := make([]shared.RequestablePermissionBase, 0, len(r.PreapprovedPermissions))
	for preapprovedPermissionsIndex := range r.PreapprovedPermissions {
		id1 := new(string)
		if !r.PreapprovedPermissions[preapprovedPermissionsIndex].ID.IsUnknown() && !r.PreapprovedPermissions[preapprovedPermissionsIndex].ID.IsNull() {
			*id1 = r.PreapprovedPermissions[preapprovedPermissionsIndex].ID.ValueString()
		} else {
			id1 = nil
		}
		preapprovedPermissions = append(preapprovedPermissions, shared.RequestablePermissionBase{
			ID: id1,
		})
	}
	preapprovedUsersByAttribute := make([]shared.AttributeEqualityRule, 0, len(r.PreapprovedUsersByAttribute))
	for preapprovedUsersByAttributeIndex := range r.PreapprovedUsersByAttribute {
		var attribute string
		attribute = r.PreapprovedUsersByAttribute[preapprovedUsersByAttributeIndex].Attribute.ValueString()

		var value string
		value = r.PreapprovedUsersByAttribute[preapprovedUsersByAttributeIndex].Value.ValueString()

		preapprovedUsersByAttribute = append(preapprovedUsersByAttribute, shared.AttributeEqualityRule{
			Attribute: attribute,
			Value:     value,
		})
	}
	preapprovalWebhooks := make([]shared.BaseInlineWebhook, 0, len(r.PreapprovalWebhooks))
	for preapprovalWebhooksIndex := range r.PreapprovalWebhooks {
		var id2 string
		id2 = r.PreapprovalWebhooks[preapprovalWebhooksIndex].ID.ValueString()

		preapprovalWebhooks = append(preapprovalWebhooks, shared.BaseInlineWebhook{
			ID: id2,
		})
	}
	out := shared.PreApprovalRuleInput{
		Justification:               justification,
		TimeBasedAccess:             timeBasedAccess,
		AppID:                       appID,
		PreapprovedGroups:           preapprovedGroups,
		PreapprovedPermissions:      preapprovedPermissions,
		PreapprovedUsersByAttribute: preapprovedUsersByAttribute,
		PreapprovalWebhooks:         preapprovalWebhooks,
	}

	return &out, diags
}

func (r *PreApprovalRuleResourceModel) ToSharedPreApprovalRuleUpdateInput(ctx context.Context) (*shared.PreApprovalRuleUpdateInput, diag.Diagnostics) {
	var diags diag.Diagnostics

	var justification string
	justification = r.Justification.ValueString()

	timeBasedAccess := make([]shared.TimeBasedAccessOptions, 0, len(r.TimeBasedAccess))
	for _, timeBasedAccessItem := range r.TimeBasedAccess {
		timeBasedAccess = append(timeBasedAccess, shared.TimeBasedAccessOptions(timeBasedAccessItem.ValueString()))
	}
	preapprovedGroups := make([]shared.BaseGroup, 0, len(r.PreapprovedGroups))
	for preapprovedGroupsIndex := range r.PreapprovedGroups {
		id := new(string)
		if !r.PreapprovedGroups[preapprovedGroupsIndex].ID.IsUnknown() && !r.PreapprovedGroups[preapprovedGroupsIndex].ID.IsNull() {
			*id = r.PreapprovedGroups[preapprovedGroupsIndex].ID.ValueString()
		} else {
			id = nil
		}
		appID := new(string)
		if !r.PreapprovedGroups[preapprovedGroupsIndex].AppID.IsUnknown() && !r.PreapprovedGroups[preapprovedGroupsIndex].AppID.IsNull() {
			*appID = r.PreapprovedGroups[preapprovedGroupsIndex].AppID.ValueString()
		} else {
			appID = nil
		}
		integrationSpecificID := new(string)
		if !r.PreapprovedGroups[preapprovedGroupsIndex].IntegrationSpecificID.IsUnknown() && !r.PreapprovedGroups[preapprovedGroupsIndex].IntegrationSpecificID.IsNull() {
			*integrationSpecificID = r.PreapprovedGroups[preapprovedGroupsIndex].IntegrationSpecificID.ValueString()
		} else {
			integrationSpecificID = nil
		}
		preapprovedGroups = append(preapprovedGroups, shared.BaseGroup{
			ID:                    id,
			AppID:                 appID,
			IntegrationSpecificID: integrationSpecificID,
		})
	}
	preapprovedPermissions := make([]shared.RequestablePermissionBase, 0, len(r.PreapprovedPermissions))
	for preapprovedPermissionsIndex := range r.PreapprovedPermissions {
		id1 := new(string)
		if !r.PreapprovedPermissions[preapprovedPermissionsIndex].ID.IsUnknown() && !r.PreapprovedPermissions[preapprovedPermissionsIndex].ID.IsNull() {
			*id1 = r.PreapprovedPermissions[preapprovedPermissionsIndex].ID.ValueString()
		} else {
			id1 = nil
		}
		preapprovedPermissions = append(preapprovedPermissions, shared.RequestablePermissionBase{
			ID: id1,
		})
	}
	preapprovedUsersByAttribute := make([]shared.AttributeEqualityRule, 0, len(r.PreapprovedUsersByAttribute))
	for preapprovedUsersByAttributeIndex := range r.PreapprovedUsersByAttribute {
		var attribute string
		attribute = r.PreapprovedUsersByAttribute[preapprovedUsersByAttributeIndex].Attribute.ValueString()

		var value string
		value = r.PreapprovedUsersByAttribute[preapprovedUsersByAttributeIndex].Value.ValueString()

		preapprovedUsersByAttribute = append(preapprovedUsersByAttribute, shared.AttributeEqualityRule{
			Attribute: attribute,
			Value:     value,
		})
	}
	preapprovalWebhooks := make([]shared.BaseInlineWebhook, 0, len(r.PreapprovalWebhooks))
	for preapprovalWebhooksIndex := range r.PreapprovalWebhooks {
		var id2 string
		id2 = r.PreapprovalWebhooks[preapprovalWebhooksIndex].ID.ValueString()

		preapprovalWebhooks = append(preapprovalWebhooks, shared.BaseInlineWebhook{
			ID: id2,
		})
	}
	out := shared.PreApprovalRuleUpdateInput{
		Justification:               justification,
		TimeBasedAccess:             timeBasedAccess,
		PreapprovedGroups:           preapprovedGroups,
		PreapprovedPermissions:      preapprovedPermissions,
		PreapprovedUsersByAttribute: preapprovedUsersByAttribute,
		PreapprovalWebhooks:         preapprovalWebhooks,
	}

	return &out, diags
}
