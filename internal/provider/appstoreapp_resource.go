// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package provider

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/boolplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/listplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/objectplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/setplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	speakeasy_boolplanmodifier "github.com/teamlumos/terraform-provider-lumos/internal/planmodifiers/boolplanmodifier"
	speakeasy_listplanmodifier "github.com/teamlumos/terraform-provider-lumos/internal/planmodifiers/listplanmodifier"
	speakeasy_objectplanmodifier "github.com/teamlumos/terraform-provider-lumos/internal/planmodifiers/objectplanmodifier"
	speakeasy_setplanmodifier "github.com/teamlumos/terraform-provider-lumos/internal/planmodifiers/setplanmodifier"
	speakeasy_stringplanmodifier "github.com/teamlumos/terraform-provider-lumos/internal/planmodifiers/stringplanmodifier"
	tfTypes "github.com/teamlumos/terraform-provider-lumos/internal/provider/types"
	"github.com/teamlumos/terraform-provider-lumos/internal/sdk"
	"github.com/teamlumos/terraform-provider-lumos/internal/sdk/models/operations"
	speakeasy_objectvalidators "github.com/teamlumos/terraform-provider-lumos/internal/validators/objectvalidators"
	speakeasy_stringvalidators "github.com/teamlumos/terraform-provider-lumos/internal/validators/stringvalidators"
)

// Ensure provider defined types fully satisfy framework interfaces.
var _ resource.Resource = &AppStoreAppResource{}
var _ resource.ResourceWithImportState = &AppStoreAppResource{}

func NewAppStoreAppResource() resource.Resource {
	return &AppStoreAppResource{}
}

// AppStoreAppResource defines the resource implementation.
type AppStoreAppResource struct {
	client *sdk.Lumos
}

// AppStoreAppResourceModel describes the resource data model.
type AppStoreAppResourceModel struct {
	AllowMultiplePermissionSelection types.Bool                                 `tfsdk:"allow_multiple_permission_selection"`
	AppClassID                       types.String                               `tfsdk:"app_class_id"`
	AppID                            types.String                               `tfsdk:"app_id"`
	CustomRequestInstructions        types.String                               `tfsdk:"custom_request_instructions"`
	ID                               types.String                               `tfsdk:"id"`
	InstanceID                       types.String                               `tfsdk:"instance_id"`
	LogoURL                          types.String                               `tfsdk:"logo_url"`
	Provisioning                     *tfTypes.AddAppToAppStoreInputProvisioning `tfsdk:"provisioning"`
	RequestFlow                      *tfTypes.AddAppToAppStoreInputRequestFlow  `tfsdk:"request_flow"`
	RequestInstructions              types.String                               `tfsdk:"request_instructions"`
	Sources                          []types.String                             `tfsdk:"sources"`
	Status                           types.String                               `tfsdk:"status"`
	UserFriendlyLabel                types.String                               `tfsdk:"user_friendly_label"`
	WebsiteURL                       types.String                               `tfsdk:"website_url"`
}

func (r *AppStoreAppResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_app_store_app"
}

func (r *AppStoreAppResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		MarkdownDescription: "AppStoreApp Resource",
		Attributes: map[string]schema.Attribute{
			"allow_multiple_permission_selection": schema.BoolAttribute{
				Computed:    true,
				Description: `Determines whether users can request multiple permissions at once.This field will be removed in subsequent API versions.`,
			},
			"app_class_id": schema.StringAttribute{
				Computed:    true,
				Description: `The non-unique ID of the service associated with this requestable permission. Depending on how it is sourced in Lumos, this may be the app's name, website, or other identifier.`,
			},
			"app_id": schema.StringAttribute{
				Required: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplaceIfConfigured(),
				},
				Description: `The ID of the app to add to the app store. Requires replacement if changed.`,
			},
			"custom_request_instructions": schema.StringAttribute{
				Computed: true,
				Optional: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplaceIfConfigured(),
					speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
				},
				Description: `AppStore App instructions that are shown to the requester. Requires replacement if changed.`,
			},
			"id": schema.StringAttribute{
				Computed:    true,
				Description: `The ID of this app.`,
			},
			"instance_id": schema.StringAttribute{
				Computed:    true,
				Description: `The non-unique ID of the instance associated with this app. This will be the Okta app id if itâ€™s an Okta app, or will be marked as custom_app_import if manually uploaded into Lumos.`,
			},
			"logo_url": schema.StringAttribute{
				Computed:    true,
				Description: `The URL of the logo of this app.`,
			},
			"provisioning": schema.SingleNestedAttribute{
				Computed: true,
				Optional: true,
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplaceIfConfigured(),
					speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
				},
				Attributes: map[string]schema.Attribute{
					"access_removal_inline_webhook": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Attributes: map[string]schema.Attribute{
							"description": schema.StringAttribute{
								Computed:    true,
								Description: `The description of this inline webhook.`,
							},
							"hook_type": schema.StringAttribute{
								Computed:    true,
								Description: `The type of this inline webhook. must be one of ["PRE_APPROVAL", "PROVISION", "DEPROVISION", "REQUEST_VALIDATION", "SIEM"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"PRE_APPROVAL",
										"PROVISION",
										"DEPROVISION",
										"REQUEST_VALIDATION",
										"SIEM",
									),
								},
							},
							"id": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `The ID of this inline webhook. Not Null; Requires replacement if changed.`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"name": schema.StringAttribute{
								Computed:    true,
								Description: `The name of this inline webhook.`,
							},
						},
						Description: `A deprovisioning webhook can be optionally associated with this app. Requires replacement if changed.`,
					},
					"allow_multiple_permission_selection": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Whether the app is configured to allow users to request multiple permissions in a single request. Requires replacement if changed.`,
					},
					"custom_provisioning_instructions": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `Only Available if manual steps is active. During the provisioning step, Lumos will send a custom message to app admins explaining how to provision a user to the app. Markdown for links and text formatting is supported. Requires replacement if changed.`,
					},
					"groups_provisioning": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `If enabled, Approvers must choose a group to provision the user to for access requests. must be one of ["DIRECT_TO_USER", "GROUPS_AND_HIDDEN", "GROUPS_AND_VISIBLE"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"DIRECT_TO_USER",
								"GROUPS_AND_HIDDEN",
								"GROUPS_AND_VISIBLE",
							),
						},
					},
					"manual_steps_needed": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `If enabled, Lumos will notify the App Admin after initial access is granted to perform additional manual steps. Note that if this option is enabled, this action must be confirmed by the App Admin in order to resolve the request. Requires replacement if changed.`,
					},
					"provisioning_webhook": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Attributes: map[string]schema.Attribute{
							"description": schema.StringAttribute{
								Computed:    true,
								Description: `The description of this inline webhook.`,
							},
							"hook_type": schema.StringAttribute{
								Computed:    true,
								Description: `The type of this inline webhook. must be one of ["PRE_APPROVAL", "PROVISION", "DEPROVISION", "REQUEST_VALIDATION", "SIEM"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"PRE_APPROVAL",
										"PROVISION",
										"DEPROVISION",
										"REQUEST_VALIDATION",
										"SIEM",
									),
								},
							},
							"id": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `The ID of this inline webhook. Not Null; Requires replacement if changed.`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"name": schema.StringAttribute{
								Computed:    true,
								Description: `The name of this inline webhook.`,
							},
						},
						Description: `The provisioning webhook optionally associated with this app. Requires replacement if changed.`,
					},
					"time_based_access": schema.ListAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						ElementType: types.StringType,
						Description: `If enabled, users can request an app for a selected duration. After expiry, Lumos will automatically remove user's access. Requires replacement if changed.`,
					},
				},
				Description: `Provisioning flow configuration to request access to app. Requires replacement if changed.`,
			},
			"request_flow": schema.SingleNestedAttribute{
				Computed: true,
				Optional: true,
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplaceIfConfigured(),
					speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
				},
				Attributes: map[string]schema.Attribute{
					"admins": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Attributes: map[string]schema.Attribute{
							"groups": schema.ListNestedAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.List{
									listplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
								},
								NestedObject: schema.NestedAttributeObject{
									Validators: []validator.Object{
										speakeasy_objectvalidators.NotNull(),
									},
									PlanModifiers: []planmodifier.Object{
										objectplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
									},
									Attributes: map[string]schema.Attribute{
										"app_id": schema.StringAttribute{
											Computed: true,
											Optional: true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.RequiresReplaceIfConfigured(),
												speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
											},
											Description: `The ID of the app that sources this group. Requires replacement if changed.`,
										},
										"description": schema.StringAttribute{
											Computed:    true,
											Description: `The description of this group.`,
										},
										"group_lifecycle": schema.StringAttribute{
											Computed:    true,
											Default:     stringdefault.StaticString("SYNCED"),
											Description: `The lifecycle of this group. Default: "SYNCED"; must be one of ["SYNCED", "NATIVE"]`,
											Validators: []validator.String{
												stringvalidator.OneOf(
													"SYNCED",
													"NATIVE",
												),
											},
										},
										"id": schema.StringAttribute{
											Computed: true,
											Optional: true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.RequiresReplaceIfConfigured(),
												speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
											},
											Description: `The ID of this group. Requires replacement if changed.`,
										},
										"integration_specific_id": schema.StringAttribute{
											Computed: true,
											Optional: true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.RequiresReplaceIfConfigured(),
												speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
											},
											Description: `The ID of this group, specific to the integration. Requires replacement if changed.`,
										},
										"name": schema.StringAttribute{
											Computed:    true,
											Description: `The name of this group.`,
										},
										"source_app_id": schema.StringAttribute{
											Computed:    true,
											Description: `The ID of the app that sources this group.`,
										},
									},
								},
								Description: `Groups assigned as app admins. Requires replacement if changed.`,
							},
							"users": schema.ListNestedAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.List{
									listplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
								},
								NestedObject: schema.NestedAttributeObject{
									Validators: []validator.Object{
										speakeasy_objectvalidators.NotNull(),
									},
									PlanModifiers: []planmodifier.Object{
										objectplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
									},
									Attributes: map[string]schema.Attribute{
										"email": schema.StringAttribute{
											Computed:    true,
											Description: `The email of this user.`,
										},
										"family_name": schema.StringAttribute{
											Computed:    true,
											Description: `The family name of this user.`,
										},
										"given_name": schema.StringAttribute{
											Computed:    true,
											Description: `The given name of this user.`,
										},
										"id": schema.StringAttribute{
											Computed: true,
											Optional: true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.RequiresReplaceIfConfigured(),
												speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
											},
											Description: `The ID of this user. Not Null; Requires replacement if changed.`,
											Validators: []validator.String{
												speakeasy_stringvalidators.NotNull(),
											},
										},
										"status": schema.StringAttribute{
											Computed:    true,
											Description: `The status of this user. must be one of ["STAGED", "ACTIVE", "SUSPENDED", "INACTIVE"]`,
											Validators: []validator.String{
												stringvalidator.OneOf(
													"STAGED",
													"ACTIVE",
													"SUSPENDED",
													"INACTIVE",
												),
											},
										},
									},
								},
								Description: `Users assigned as app admins. Requires replacement if changed.`,
							},
						},
						Description: `AppStore App admins assigned. Requires replacement if changed.`,
					},
					"allowed_groups": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Attributes: map[string]schema.Attribute{
							"groups": schema.SetNestedAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.Set{
									setplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_setplanmodifier.SuppressDiff(speakeasy_setplanmodifier.ExplicitSuppress),
								},
								NestedObject: schema.NestedAttributeObject{
									Validators: []validator.Object{
										speakeasy_objectvalidators.NotNull(),
									},
									PlanModifiers: []planmodifier.Object{
										objectplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
									},
									Attributes: map[string]schema.Attribute{
										"app_id": schema.StringAttribute{
											Computed: true,
											Optional: true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.RequiresReplaceIfConfigured(),
												speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
											},
											Description: `The ID of the app that sources this group. Requires replacement if changed.`,
										},
										"description": schema.StringAttribute{
											Computed:    true,
											Description: `The description of this group.`,
										},
										"group_lifecycle": schema.StringAttribute{
											Computed:    true,
											Default:     stringdefault.StaticString("SYNCED"),
											Description: `The lifecycle of this group. Default: "SYNCED"; must be one of ["SYNCED", "NATIVE"]`,
											Validators: []validator.String{
												stringvalidator.OneOf(
													"SYNCED",
													"NATIVE",
												),
											},
										},
										"id": schema.StringAttribute{
											Computed: true,
											Optional: true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.RequiresReplaceIfConfigured(),
												speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
											},
											Description: `The ID of this group. Requires replacement if changed.`,
										},
										"integration_specific_id": schema.StringAttribute{
											Computed: true,
											Optional: true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.RequiresReplaceIfConfigured(),
												speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
											},
											Description: `The ID of this group, specific to the integration. Requires replacement if changed.`,
										},
										"name": schema.StringAttribute{
											Computed:    true,
											Description: `The name of this group.`,
										},
										"source_app_id": schema.StringAttribute{
											Computed:    true,
											Description: `The ID of the app that sources this group.`,
										},
									},
								},
								Description: `The groups allowed to request this permission. Requires replacement if changed.`,
							},
							"type": schema.StringAttribute{
								Computed: true,
								Optional: true,
								Default:  stringdefault.StaticString("ALL_GROUPS"),
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `The type of this allowed groups config, can be all groups or specific. Default: "ALL_GROUPS"; must be one of ["ALL_GROUPS", "SPECIFIED_GROUPS"]; Requires replacement if changed.`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"ALL_GROUPS",
										"SPECIFIED_GROUPS",
									),
								},
							},
						},
						Description: `The allowed groups associated with this config. Requires replacement if changed.`,
					},
					"approvers": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Attributes: map[string]schema.Attribute{
							"groups": schema.SetNestedAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.Set{
									setplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_setplanmodifier.SuppressDiff(speakeasy_setplanmodifier.ExplicitSuppress),
								},
								NestedObject: schema.NestedAttributeObject{
									Validators: []validator.Object{
										speakeasy_objectvalidators.NotNull(),
									},
									PlanModifiers: []planmodifier.Object{
										objectplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
									},
									Attributes: map[string]schema.Attribute{
										"app_id": schema.StringAttribute{
											Computed: true,
											Optional: true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.RequiresReplaceIfConfigured(),
												speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
											},
											Description: `The ID of the app that sources this group. Requires replacement if changed.`,
										},
										"description": schema.StringAttribute{
											Computed:    true,
											Description: `The description of this group.`,
										},
										"group_lifecycle": schema.StringAttribute{
											Computed:    true,
											Default:     stringdefault.StaticString("SYNCED"),
											Description: `The lifecycle of this group. Default: "SYNCED"; must be one of ["SYNCED", "NATIVE"]`,
											Validators: []validator.String{
												stringvalidator.OneOf(
													"SYNCED",
													"NATIVE",
												),
											},
										},
										"id": schema.StringAttribute{
											Computed: true,
											Optional: true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.RequiresReplaceIfConfigured(),
												speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
											},
											Description: `The ID of this group. Requires replacement if changed.`,
										},
										"integration_specific_id": schema.StringAttribute{
											Computed: true,
											Optional: true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.RequiresReplaceIfConfigured(),
												speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
											},
											Description: `The ID of this group, specific to the integration. Requires replacement if changed.`,
										},
										"name": schema.StringAttribute{
											Computed:    true,
											Description: `The name of this group.`,
										},
										"source_app_id": schema.StringAttribute{
											Computed:    true,
											Description: `The ID of the app that sources this group.`,
										},
									},
								},
								Description: `Groups assigned as support request approvers. Requires replacement if changed.`,
							},
							"users": schema.SetNestedAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.Set{
									setplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_setplanmodifier.SuppressDiff(speakeasy_setplanmodifier.ExplicitSuppress),
								},
								NestedObject: schema.NestedAttributeObject{
									Validators: []validator.Object{
										speakeasy_objectvalidators.NotNull(),
									},
									PlanModifiers: []planmodifier.Object{
										objectplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
									},
									Attributes: map[string]schema.Attribute{
										"email": schema.StringAttribute{
											Computed:    true,
											Description: `The email of this user.`,
										},
										"family_name": schema.StringAttribute{
											Computed:    true,
											Description: `The family name of this user.`,
										},
										"given_name": schema.StringAttribute{
											Computed:    true,
											Description: `The given name of this user.`,
										},
										"id": schema.StringAttribute{
											Computed: true,
											Optional: true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.RequiresReplaceIfConfigured(),
												speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
											},
											Description: `The ID of this user. Not Null; Requires replacement if changed.`,
											Validators: []validator.String{
												speakeasy_stringvalidators.NotNull(),
											},
										},
										"status": schema.StringAttribute{
											Computed:    true,
											Description: `The status of this user. must be one of ["STAGED", "ACTIVE", "SUSPENDED", "INACTIVE"]`,
											Validators: []validator.String{
												stringvalidator.OneOf(
													"STAGED",
													"ACTIVE",
													"SUSPENDED",
													"INACTIVE",
												),
											},
										},
									},
								},
								Description: `Users assigned as support request approvers. Requires replacement if changed.`,
							},
						},
						Description: `AppStore App approvers assigned. Requires replacement if changed.`,
					},
					"approvers_stage_2": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Attributes: map[string]schema.Attribute{
							"groups": schema.SetNestedAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.Set{
									setplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_setplanmodifier.SuppressDiff(speakeasy_setplanmodifier.ExplicitSuppress),
								},
								NestedObject: schema.NestedAttributeObject{
									Validators: []validator.Object{
										speakeasy_objectvalidators.NotNull(),
									},
									PlanModifiers: []planmodifier.Object{
										objectplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
									},
									Attributes: map[string]schema.Attribute{
										"app_id": schema.StringAttribute{
											Computed: true,
											Optional: true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.RequiresReplaceIfConfigured(),
												speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
											},
											Description: `The ID of the app that sources this group. Requires replacement if changed.`,
										},
										"description": schema.StringAttribute{
											Computed:    true,
											Description: `The description of this group.`,
										},
										"group_lifecycle": schema.StringAttribute{
											Computed:    true,
											Default:     stringdefault.StaticString("SYNCED"),
											Description: `The lifecycle of this group. Default: "SYNCED"; must be one of ["SYNCED", "NATIVE"]`,
											Validators: []validator.String{
												stringvalidator.OneOf(
													"SYNCED",
													"NATIVE",
												),
											},
										},
										"id": schema.StringAttribute{
											Computed: true,
											Optional: true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.RequiresReplaceIfConfigured(),
												speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
											},
											Description: `The ID of this group. Requires replacement if changed.`,
										},
										"integration_specific_id": schema.StringAttribute{
											Computed: true,
											Optional: true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.RequiresReplaceIfConfigured(),
												speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
											},
											Description: `The ID of this group, specific to the integration. Requires replacement if changed.`,
										},
										"name": schema.StringAttribute{
											Computed:    true,
											Description: `The name of this group.`,
										},
										"source_app_id": schema.StringAttribute{
											Computed:    true,
											Description: `The ID of the app that sources this group.`,
										},
									},
								},
								Description: `Groups assigned as support request approvers. Requires replacement if changed.`,
							},
							"users": schema.SetNestedAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.Set{
									setplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_setplanmodifier.SuppressDiff(speakeasy_setplanmodifier.ExplicitSuppress),
								},
								NestedObject: schema.NestedAttributeObject{
									Validators: []validator.Object{
										speakeasy_objectvalidators.NotNull(),
									},
									PlanModifiers: []planmodifier.Object{
										objectplanmodifier.RequiresReplaceIfConfigured(),
										speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
									},
									Attributes: map[string]schema.Attribute{
										"email": schema.StringAttribute{
											Computed:    true,
											Description: `The email of this user.`,
										},
										"family_name": schema.StringAttribute{
											Computed:    true,
											Description: `The family name of this user.`,
										},
										"given_name": schema.StringAttribute{
											Computed:    true,
											Description: `The given name of this user.`,
										},
										"id": schema.StringAttribute{
											Computed: true,
											Optional: true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.RequiresReplaceIfConfigured(),
												speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
											},
											Description: `The ID of this user. Not Null; Requires replacement if changed.`,
											Validators: []validator.String{
												speakeasy_stringvalidators.NotNull(),
											},
										},
										"status": schema.StringAttribute{
											Computed:    true,
											Description: `The status of this user. must be one of ["STAGED", "ACTIVE", "SUSPENDED", "INACTIVE"]`,
											Validators: []validator.String{
												stringvalidator.OneOf(
													"STAGED",
													"ACTIVE",
													"SUSPENDED",
													"INACTIVE",
												),
											},
										},
									},
								},
								Description: `Users assigned as support request approvers. Requires replacement if changed.`,
							},
						},
						Description: `AppStore App stage 2 approvers assigned. Requires replacement if changed.`,
					},
					"custom_approval_message": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `After the approval step, send a custom message to requesters. Markdown for links and text formatting is supported. Requires replacement if changed.`,
					},
					"discoverability": schema.StringAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Description: `AppStore App visibility. must be one of ["FULL", "LIMITED", "NONE"]; Requires replacement if changed.`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"FULL",
								"LIMITED",
								"NONE",
							),
						},
					},
					"request_validation_inline_webhook": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Attributes: map[string]schema.Attribute{
							"description": schema.StringAttribute{
								Computed:    true,
								Description: `The description of this inline webhook.`,
							},
							"hook_type": schema.StringAttribute{
								Computed:    true,
								Description: `The type of this inline webhook. must be one of ["PRE_APPROVAL", "PROVISION", "DEPROVISION", "REQUEST_VALIDATION", "SIEM"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"PRE_APPROVAL",
										"PROVISION",
										"DEPROVISION",
										"REQUEST_VALIDATION",
										"SIEM",
									),
								},
							},
							"id": schema.StringAttribute{
								Computed: true,
								Optional: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Description: `The ID of this inline webhook. Not Null; Requires replacement if changed.`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"name": schema.StringAttribute{
								Computed:    true,
								Description: `The name of this inline webhook.`,
							},
						},
						Description: `A request validation webhook can be optionally associated with this app. Requires replacement if changed.`,
					},
					"require_additional_approval": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `Only turn on when working with sensitive permissions to ensure a smooth employee experience. Requires replacement if changed.`,
					},
					"require_manager_approval": schema.BoolAttribute{
						Computed: true,
						Optional: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Description: `When a user makes an access request, require that their manager approves the request before moving on to additional approvals. Requires replacement if changed.`,
					},
				},
				Description: `Request flow configuration to request access to app. Requires replacement if changed.`,
			},
			"request_instructions": schema.StringAttribute{
				Computed:    true,
				Description: `The request instructions.`,
			},
			"sources": schema.ListAttribute{
				Computed:    true,
				ElementType: types.StringType,
				Description: `The sources of this app.`,
			},
			"status": schema.StringAttribute{
				Computed:    true,
				Description: `The status of this app. Possible values: 'DISCOVERED', 'NEEDS_REVIEW', 'APPROVED', 'BLOCKLISTED', 'DEPRECATED'. must be one of ["DISCOVERED", "NEEDS_REVIEW", "APPROVED", "BLOCKLISTED", "DEPRECATED"]`,
				Validators: []validator.String{
					stringvalidator.OneOf(
						"DISCOVERED",
						"NEEDS_REVIEW",
						"APPROVED",
						"BLOCKLISTED",
						"DEPRECATED",
					),
				},
			},
			"user_friendly_label": schema.StringAttribute{
				Computed:    true,
				Description: `The user-friendly label of this app.`,
			},
			"website_url": schema.StringAttribute{
				Computed:    true,
				Description: `The URL of the website of this app.`,
			},
		},
	}
}

func (r *AppStoreAppResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	// Prevent panic if the provider has not been configured.
	if req.ProviderData == nil {
		return
	}

	client, ok := req.ProviderData.(*sdk.Lumos)

	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *sdk.Lumos, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)

		return
	}

	r.client = client
}

func (r *AppStoreAppResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data *AppStoreAppResourceModel
	var plan types.Object

	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(plan.As(ctx, &data, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)

	if resp.Diagnostics.HasError() {
		return
	}

	request := *data.ToSharedAddAppToAppStoreInput()
	res, err := r.client.AppStore.AddAppToAppStore(ctx, request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}
	if !(res.AppStoreAppSettingsOutput != nil) {
		resp.Diagnostics.AddError("unexpected response from API. Got an unexpected response body", debugResponse(res.RawResponse))
		return
	}
	data.RefreshFromSharedAppStoreAppSettingsOutput(res.AppStoreAppSettingsOutput)
	refreshPlan(ctx, plan, &data, resp.Diagnostics)
	var appID string
	appID = data.AppID.ValueString()

	request1 := operations.GetAppStoreAppRequest{
		AppID: appID,
	}
	res1, err := r.client.AppStore.GetAppStoreApp(ctx, request1)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res1 != nil && res1.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res1.RawResponse))
		}
		return
	}
	if res1 == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res1))
		return
	}
	if res1.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res1.StatusCode), debugResponse(res1.RawResponse))
		return
	}
	if !(res1.AppStoreApp != nil) {
		resp.Diagnostics.AddError("unexpected response from API. Got an unexpected response body", debugResponse(res1.RawResponse))
		return
	}
	data.RefreshFromSharedAppStoreApp(res1.AppStoreApp)
	refreshPlan(ctx, plan, &data, resp.Diagnostics)

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *AppStoreAppResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data *AppStoreAppResourceModel
	var item types.Object

	resp.Diagnostics.Append(req.State.Get(ctx, &item)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(item.As(ctx, &data, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)

	if resp.Diagnostics.HasError() {
		return
	}

	var appID string
	appID = data.AppID.ValueString()

	request := operations.GetAppStoreAppRequest{
		AppID: appID,
	}
	res, err := r.client.AppStore.GetAppStoreApp(ctx, request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode == 404 {
		resp.State.RemoveResource(ctx)
		return
	}
	if res.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}
	if !(res.AppStoreApp != nil) {
		resp.Diagnostics.AddError("unexpected response from API. Got an unexpected response body", debugResponse(res.RawResponse))
		return
	}
	data.RefreshFromSharedAppStoreApp(res.AppStoreApp)

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *AppStoreAppResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var data *AppStoreAppResourceModel
	var plan types.Object

	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	merge(ctx, req, resp, &data)
	if resp.Diagnostics.HasError() {
		return
	}

	// Not Implemented; all attributes marked as RequiresReplace

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *AppStoreAppResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data *AppStoreAppResourceModel
	var item types.Object

	resp.Diagnostics.Append(req.State.Get(ctx, &item)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(item.As(ctx, &data, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)

	if resp.Diagnostics.HasError() {
		return
	}

	var appID string
	appID = data.AppID.ValueString()

	request := operations.RemoveAppFromAppStoreRequest{
		AppID: appID,
	}
	res, err := r.client.AppStore.RemoveAppFromAppStore(ctx, request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}

}

func (r *AppStoreAppResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("app_id"), req.ID)...)
}
