// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package provider

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/boolplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/listplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/objectplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	speakeasy_boolplanmodifier "github.com/teamlumos/terraform-provider-lumos/internal/planmodifiers/boolplanmodifier"
	speakeasy_listplanmodifier "github.com/teamlumos/terraform-provider-lumos/internal/planmodifiers/listplanmodifier"
	speakeasy_objectplanmodifier "github.com/teamlumos/terraform-provider-lumos/internal/planmodifiers/objectplanmodifier"
	speakeasy_stringplanmodifier "github.com/teamlumos/terraform-provider-lumos/internal/planmodifiers/stringplanmodifier"
	tfTypes "github.com/teamlumos/terraform-provider-lumos/internal/provider/types"
	"github.com/teamlumos/terraform-provider-lumos/internal/sdk"
	"github.com/teamlumos/terraform-provider-lumos/internal/sdk/models/operations"
	speakeasy_stringvalidators "github.com/teamlumos/terraform-provider-lumos/internal/validators/stringvalidators"
)

// Ensure provider defined types fully satisfy framework interfaces.
var _ resource.Resource = &AppStoreAppResource{}
var _ resource.ResourceWithImportState = &AppStoreAppResource{}

func NewAppStoreAppResource() resource.Resource {
	return &AppStoreAppResource{}
}

// AppStoreAppResource defines the resource implementation.
type AppStoreAppResource struct {
	client *sdk.Lumos
}

// AppStoreAppResourceModel describes the resource data model.
type AppStoreAppResourceModel struct {
	AllowMultiplePermissionSelection types.Bool                                 `tfsdk:"allow_multiple_permission_selection"`
	AppClassID                       types.String                               `tfsdk:"app_class_id"`
	AppID                            types.String                               `tfsdk:"app_id"`
	CustomRequestInstructions        types.String                               `tfsdk:"custom_request_instructions"`
	ID                               types.String                               `tfsdk:"id"`
	InstanceID                       types.String                               `tfsdk:"instance_id"`
	LogoURL                          types.String                               `tfsdk:"logo_url"`
	Provisioning                     *tfTypes.AddAppToAppStoreInputProvisioning `tfsdk:"provisioning"`
	RequestFlow                      *tfTypes.AddAppToAppStoreInputRequestFlow  `tfsdk:"request_flow"`
	RequestInstructions              types.String                               `tfsdk:"request_instructions"`
	Sources                          []types.String                             `tfsdk:"sources"`
	Status                           types.String                               `tfsdk:"status"`
	UserFriendlyLabel                types.String                               `tfsdk:"user_friendly_label"`
	WebsiteURL                       types.String                               `tfsdk:"website_url"`
}

func (r *AppStoreAppResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_app_store_app"
}

func (r *AppStoreAppResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		MarkdownDescription: "AppStoreApp Resource",
		Attributes: map[string]schema.Attribute{
			"allow_multiple_permission_selection": schema.BoolAttribute{
				Computed:    true,
				Description: `Whether the app is configured to allow multiple permissions to be requested at a time. This field will be removed in subsequent API versions.`,
			},
			"app_class_id": schema.StringAttribute{
				Computed:    true,
				Description: `The ID of the service associated with this app.`,
			},
			"app_id": schema.StringAttribute{
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplaceIfConfigured(),
				},
				Required:    true,
				Description: `The ID of the app to add to the app store. Requires replacement if changed. `,
			},
			"custom_request_instructions": schema.StringAttribute{
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplaceIfConfigured(),
					speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
				},
				Optional:    true,
				Description: `AppStore App instructions. Requires replacement if changed. `,
			},
			"id": schema.StringAttribute{
				Computed:    true,
				Description: `The ID of this app.`,
			},
			"instance_id": schema.StringAttribute{
				Computed:    true,
				Description: `The ID of the instance associated with this app.`,
			},
			"logo_url": schema.StringAttribute{
				Computed:    true,
				Description: `The URL of the logo of this app.`,
			},
			"provisioning": schema.SingleNestedAttribute{
				Computed: true,
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplaceIfConfigured(),
					speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
				},
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"access_removal_inline_webhook": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"description": schema.StringAttribute{
								Computed:    true,
								Description: `The description of this inline webhook.`,
							},
							"hook_type": schema.StringAttribute{
								Computed:    true,
								Description: `An enumeration. must be one of ["PRE_APPROVAL", "PROVISION", "DEPROVISION", "REQUEST_VALIDATION", "SIEM"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"PRE_APPROVAL",
										"PROVISION",
										"DEPROVISION",
										"REQUEST_VALIDATION",
										"SIEM",
									),
								},
							},
							"id": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The ID of this inline webhook. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"name": schema.StringAttribute{
								Computed:    true,
								Description: `The name of this inline webhook.`,
							},
						},
						Description: `An inactivity workflow can be optionally associated with this app. Requires replacement if changed. `,
					},
					"allow_multiple_permission_selection": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Optional:    true,
						Description: `Whether the app is configured to allow users to request multiple permissions in a single request. Requires replacement if changed. `,
					},
					"custom_provisioning_instructions": schema.StringAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Optional:    true,
						Description: `Only Available if manual steps is active. During the provisioning step, send a custom message to app admins explaining how to provision a user to the app. Markdown for links and text formatting is supported. Requires replacement if changed. `,
					},
					"groups_provisioning": schema.StringAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Optional:    true,
						Description: `An enumeration. Requires replacement if changed. ; must be one of ["DIRECT_TO_USER", "GROUPS_AND_HIDDEN", "GROUPS_AND_VISIBLE"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"DIRECT_TO_USER",
								"GROUPS_AND_HIDDEN",
								"GROUPS_AND_VISIBLE",
							),
						},
					},
					"manual_steps_needed": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Optional:    true,
						Description: `If enabled, Lumos will reach out to the App Admin after initial access is granted to perform additional manual steps. Note that if this option is enabled, this action must be confirmed by the App Admin in order to resolve the request. Requires replacement if changed. `,
					},
					"provisioning_webhook": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"description": schema.StringAttribute{
								Computed:    true,
								Description: `The description of this inline webhook.`,
							},
							"hook_type": schema.StringAttribute{
								Computed:    true,
								Description: `An enumeration. must be one of ["PRE_APPROVAL", "PROVISION", "DEPROVISION", "REQUEST_VALIDATION", "SIEM"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"PRE_APPROVAL",
										"PROVISION",
										"DEPROVISION",
										"REQUEST_VALIDATION",
										"SIEM",
									),
								},
							},
							"id": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The ID of this inline webhook. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"name": schema.StringAttribute{
								Computed:    true,
								Description: `The name of this inline webhook.`,
							},
						},
						Description: `The provisioning webhook optionally associated with this app. Requires replacement if changed. `,
					},
					"time_based_access": schema.ListAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.List{
							listplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
						},
						Optional:    true,
						ElementType: types.StringType,
						Description: `If enabled, users can request an app for a selected duration. After expiry, Lumos will automatically remove user's access. Requires replacement if changed. `,
					},
				},
				Description: `Provisioning flow configuration to request access to app. Requires replacement if changed. `,
			},
			"request_flow": schema.SingleNestedAttribute{
				Computed: true,
				PlanModifiers: []planmodifier.Object{
					objectplanmodifier.RequiresReplaceIfConfigured(),
					speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
				},
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"admins": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"groups": schema.ListNestedAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.List{
									listplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
								},
								Optional: true,
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"app_id": schema.StringAttribute{
											Computed: true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.RequiresReplaceIfConfigured(),
												speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
											},
											Optional:    true,
											Description: `The ID of the app that owns this group. Requires replacement if changed. `,
										},
										"description": schema.StringAttribute{
											Computed:    true,
											Description: `The description of this group.`,
										},
										"group_lifecycle": schema.StringAttribute{
											Computed:    true,
											Description: `The lifecycle of this group. must be one of ["SYNCED", "NATIVE"]`,
											Validators: []validator.String{
												stringvalidator.OneOf(
													"SYNCED",
													"NATIVE",
												),
											},
										},
										"id": schema.StringAttribute{
											Computed: true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.RequiresReplaceIfConfigured(),
												speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
											},
											Optional:    true,
											Description: `The ID of this group. Requires replacement if changed. `,
										},
										"integration_specific_id": schema.StringAttribute{
											Computed: true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.RequiresReplaceIfConfigured(),
												speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
											},
											Optional:    true,
											Description: `The ID of this group, specific to the integration. Requires replacement if changed. `,
										},
										"name": schema.StringAttribute{
											Computed:    true,
											Description: `The name of this group.`,
										},
										"source_app_id": schema.StringAttribute{
											Computed:    true,
											Description: `The ID of the app that owns this group.`,
										},
									},
								},
								Description: `Groups assigned as app admins. Requires replacement if changed. `,
							},
							"users": schema.ListNestedAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.List{
									listplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
								},
								Optional: true,
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"email": schema.StringAttribute{
											Computed:    true,
											Description: `The email of this user.`,
										},
										"family_name": schema.StringAttribute{
											Computed:    true,
											Description: `The family name of this user.`,
										},
										"given_name": schema.StringAttribute{
											Computed:    true,
											Description: `The given name of this user.`,
										},
										"id": schema.StringAttribute{
											Computed: true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.RequiresReplaceIfConfigured(),
												speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
											},
											Optional:    true,
											Description: `The ID of this user. Requires replacement if changed. ; Not Null`,
											Validators: []validator.String{
												speakeasy_stringvalidators.NotNull(),
											},
										},
										"status": schema.StringAttribute{
											Computed:    true,
											Description: `An enumeration. must be one of ["STAGED", "ACTIVE", "SUSPENDED", "INACTIVE"]`,
											Validators: []validator.String{
												stringvalidator.OneOf(
													"STAGED",
													"ACTIVE",
													"SUSPENDED",
													"INACTIVE",
												),
											},
										},
									},
								},
								Description: `Users assigned as app admins. Requires replacement if changed. `,
							},
						},
						Description: `AppStore App admins assigned. Requires replacement if changed. `,
					},
					"allowed_groups": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"groups": schema.ListNestedAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.List{
									listplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
								},
								Optional: true,
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"app_id": schema.StringAttribute{
											Computed: true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.RequiresReplaceIfConfigured(),
												speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
											},
											Optional:    true,
											Description: `The ID of the app that owns this group. Requires replacement if changed. `,
										},
										"description": schema.StringAttribute{
											Computed:    true,
											Description: `The description of this group.`,
										},
										"group_lifecycle": schema.StringAttribute{
											Computed:    true,
											Description: `The lifecycle of this group. must be one of ["SYNCED", "NATIVE"]`,
											Validators: []validator.String{
												stringvalidator.OneOf(
													"SYNCED",
													"NATIVE",
												),
											},
										},
										"id": schema.StringAttribute{
											Computed: true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.RequiresReplaceIfConfigured(),
												speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
											},
											Optional:    true,
											Description: `The ID of this group. Requires replacement if changed. `,
										},
										"integration_specific_id": schema.StringAttribute{
											Computed: true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.RequiresReplaceIfConfigured(),
												speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
											},
											Optional:    true,
											Description: `The ID of this group, specific to the integration. Requires replacement if changed. `,
										},
										"name": schema.StringAttribute{
											Computed:    true,
											Description: `The name of this group.`,
										},
										"source_app_id": schema.StringAttribute{
											Computed:    true,
											Description: `The ID of the app that owns this group.`,
										},
									},
								},
								Description: `The groups associated with this config. Requires replacement if changed. `,
							},
							"type": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Default:     stringdefault.StaticString("ALL_GROUPS"),
								Description: `The type of this allowed groups config, can be all groups or specific. Requires replacement if changed. ; must be one of ["ALL_GROUPS", "SPECIFIED_GROUPS"]; Default: "ALL_GROUPS"`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"ALL_GROUPS",
										"SPECIFIED_GROUPS",
									),
								},
							},
						},
						Description: `The allowed groups associated with this config. Requires replacement if changed. `,
					},
					"approvers": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"groups": schema.ListNestedAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.List{
									listplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
								},
								Optional: true,
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"app_id": schema.StringAttribute{
											Computed: true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.RequiresReplaceIfConfigured(),
												speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
											},
											Optional:    true,
											Description: `The ID of the app that owns this group. Requires replacement if changed. `,
										},
										"description": schema.StringAttribute{
											Computed:    true,
											Description: `The description of this group.`,
										},
										"group_lifecycle": schema.StringAttribute{
											Computed:    true,
											Description: `The lifecycle of this group. must be one of ["SYNCED", "NATIVE"]`,
											Validators: []validator.String{
												stringvalidator.OneOf(
													"SYNCED",
													"NATIVE",
												),
											},
										},
										"id": schema.StringAttribute{
											Computed: true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.RequiresReplaceIfConfigured(),
												speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
											},
											Optional:    true,
											Description: `The ID of this group. Requires replacement if changed. `,
										},
										"integration_specific_id": schema.StringAttribute{
											Computed: true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.RequiresReplaceIfConfigured(),
												speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
											},
											Optional:    true,
											Description: `The ID of this group, specific to the integration. Requires replacement if changed. `,
										},
										"name": schema.StringAttribute{
											Computed:    true,
											Description: `The name of this group.`,
										},
										"source_app_id": schema.StringAttribute{
											Computed:    true,
											Description: `The ID of the app that owns this group.`,
										},
									},
								},
								Description: `Groups assigned as support request approvers. Requires replacement if changed. `,
							},
							"users": schema.ListNestedAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.List{
									listplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
								},
								Optional: true,
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"email": schema.StringAttribute{
											Computed:    true,
											Description: `The email of this user.`,
										},
										"family_name": schema.StringAttribute{
											Computed:    true,
											Description: `The family name of this user.`,
										},
										"given_name": schema.StringAttribute{
											Computed:    true,
											Description: `The given name of this user.`,
										},
										"id": schema.StringAttribute{
											Computed: true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.RequiresReplaceIfConfigured(),
												speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
											},
											Optional:    true,
											Description: `The ID of this user. Requires replacement if changed. ; Not Null`,
											Validators: []validator.String{
												speakeasy_stringvalidators.NotNull(),
											},
										},
										"status": schema.StringAttribute{
											Computed:    true,
											Description: `An enumeration. must be one of ["STAGED", "ACTIVE", "SUSPENDED", "INACTIVE"]`,
											Validators: []validator.String{
												stringvalidator.OneOf(
													"STAGED",
													"ACTIVE",
													"SUSPENDED",
													"INACTIVE",
												),
											},
										},
									},
								},
								Description: `Users assigned as support request approvers. Requires replacement if changed. `,
							},
						},
						Description: `AppStore App approvers assigned. Requires replacement if changed. `,
					},
					"approvers_stage_2": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"groups": schema.ListNestedAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.List{
									listplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
								},
								Optional: true,
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"app_id": schema.StringAttribute{
											Computed: true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.RequiresReplaceIfConfigured(),
												speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
											},
											Optional:    true,
											Description: `The ID of the app that owns this group. Requires replacement if changed. `,
										},
										"description": schema.StringAttribute{
											Computed:    true,
											Description: `The description of this group.`,
										},
										"group_lifecycle": schema.StringAttribute{
											Computed:    true,
											Description: `The lifecycle of this group. must be one of ["SYNCED", "NATIVE"]`,
											Validators: []validator.String{
												stringvalidator.OneOf(
													"SYNCED",
													"NATIVE",
												),
											},
										},
										"id": schema.StringAttribute{
											Computed: true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.RequiresReplaceIfConfigured(),
												speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
											},
											Optional:    true,
											Description: `The ID of this group. Requires replacement if changed. `,
										},
										"integration_specific_id": schema.StringAttribute{
											Computed: true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.RequiresReplaceIfConfigured(),
												speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
											},
											Optional:    true,
											Description: `The ID of this group, specific to the integration. Requires replacement if changed. `,
										},
										"name": schema.StringAttribute{
											Computed:    true,
											Description: `The name of this group.`,
										},
										"source_app_id": schema.StringAttribute{
											Computed:    true,
											Description: `The ID of the app that owns this group.`,
										},
									},
								},
								Description: `Groups assigned as support request approvers. Requires replacement if changed. `,
							},
							"users": schema.ListNestedAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.List{
									listplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_listplanmodifier.SuppressDiff(speakeasy_listplanmodifier.ExplicitSuppress),
								},
								Optional: true,
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"email": schema.StringAttribute{
											Computed:    true,
											Description: `The email of this user.`,
										},
										"family_name": schema.StringAttribute{
											Computed:    true,
											Description: `The family name of this user.`,
										},
										"given_name": schema.StringAttribute{
											Computed:    true,
											Description: `The given name of this user.`,
										},
										"id": schema.StringAttribute{
											Computed: true,
											PlanModifiers: []planmodifier.String{
												stringplanmodifier.RequiresReplaceIfConfigured(),
												speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
											},
											Optional:    true,
											Description: `The ID of this user. Requires replacement if changed. ; Not Null`,
											Validators: []validator.String{
												speakeasy_stringvalidators.NotNull(),
											},
										},
										"status": schema.StringAttribute{
											Computed:    true,
											Description: `An enumeration. must be one of ["STAGED", "ACTIVE", "SUSPENDED", "INACTIVE"]`,
											Validators: []validator.String{
												stringvalidator.OneOf(
													"STAGED",
													"ACTIVE",
													"SUSPENDED",
													"INACTIVE",
												),
											},
										},
									},
								},
								Description: `Users assigned as support request approvers. Requires replacement if changed. `,
							},
						},
						Description: `AppStore App stage 2 approvers assigned. Requires replacement if changed. `,
					},
					"custom_approval_message": schema.StringAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Optional:    true,
						Description: `During the approval step, send a custom message to requesters. Markdown for links and text formatting is supported. Requires replacement if changed. `,
					},
					"discoverability": schema.StringAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.String{
							stringplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
						},
						Optional:    true,
						Description: `An enumeration. Requires replacement if changed. ; must be one of ["FULL", "LIMITED", "NONE"]`,
						Validators: []validator.String{
							stringvalidator.OneOf(
								"FULL",
								"LIMITED",
								"NONE",
							),
						},
					},
					"request_validation_inline_webhook": schema.SingleNestedAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Object{
							objectplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_objectplanmodifier.SuppressDiff(speakeasy_objectplanmodifier.ExplicitSuppress),
						},
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"description": schema.StringAttribute{
								Computed:    true,
								Description: `The description of this inline webhook.`,
							},
							"hook_type": schema.StringAttribute{
								Computed:    true,
								Description: `An enumeration. must be one of ["PRE_APPROVAL", "PROVISION", "DEPROVISION", "REQUEST_VALIDATION", "SIEM"]`,
								Validators: []validator.String{
									stringvalidator.OneOf(
										"PRE_APPROVAL",
										"PROVISION",
										"DEPROVISION",
										"REQUEST_VALIDATION",
										"SIEM",
									),
								},
							},
							"id": schema.StringAttribute{
								Computed: true,
								PlanModifiers: []planmodifier.String{
									stringplanmodifier.RequiresReplaceIfConfigured(),
									speakeasy_stringplanmodifier.SuppressDiff(speakeasy_stringplanmodifier.ExplicitSuppress),
								},
								Optional:    true,
								Description: `The ID of this inline webhook. Requires replacement if changed. ; Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"name": schema.StringAttribute{
								Computed:    true,
								Description: `The name of this inline webhook.`,
							},
						},
						Description: `A request validation webhook can be optionally associated with this app. Requires replacement if changed. `,
					},
					"require_additional_approval": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Optional:    true,
						Description: `Only turn on when working with sensitive permissions to ensure a smooth employee experience. Requires replacement if changed. `,
					},
					"require_manager_approval": schema.BoolAttribute{
						Computed: true,
						PlanModifiers: []planmodifier.Bool{
							boolplanmodifier.RequiresReplaceIfConfigured(),
							speakeasy_boolplanmodifier.SuppressDiff(speakeasy_boolplanmodifier.ExplicitSuppress),
						},
						Optional:    true,
						Description: `When a user makes an access request, require that their manager approves the request before moving on to additional approvals. Requires replacement if changed. `,
					},
				},
				Description: `Request flow configuration to request access to app. Requires replacement if changed. `,
			},
			"request_instructions": schema.StringAttribute{
				Computed:    true,
				Description: `The request instructions.`,
			},
			"sources": schema.ListAttribute{
				Computed:    true,
				ElementType: types.StringType,
				Description: `The sources of this app.`,
			},
			"status": schema.StringAttribute{
				Computed:    true,
				Description: `An enumeration. must be one of ["DISCOVERED", "NEEDS_REVIEW", "APPROVED", "BLOCKLISTED", "DEPRECATED"]`,
				Validators: []validator.String{
					stringvalidator.OneOf(
						"DISCOVERED",
						"NEEDS_REVIEW",
						"APPROVED",
						"BLOCKLISTED",
						"DEPRECATED",
					),
				},
			},
			"user_friendly_label": schema.StringAttribute{
				Computed:    true,
				Description: `The user-friendly label of this app.`,
			},
			"website_url": schema.StringAttribute{
				Computed:    true,
				Description: `The URL of the website of this app.`,
			},
		},
	}
}

func (r *AppStoreAppResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	// Prevent panic if the provider has not been configured.
	if req.ProviderData == nil {
		return
	}

	client, ok := req.ProviderData.(*sdk.Lumos)

	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *sdk.Lumos, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)

		return
	}

	r.client = client
}

func (r *AppStoreAppResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data *AppStoreAppResourceModel
	var plan types.Object

	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(plan.As(ctx, &data, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)

	if resp.Diagnostics.HasError() {
		return
	}

	request := *data.ToSharedAddAppToAppStoreInput()
	res, err := r.client.AppStore.AddAppToAppStore(ctx, request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}
	if !(res.AppStoreAppSettingsOutput != nil) {
		resp.Diagnostics.AddError("unexpected response from API. Got an unexpected response body", debugResponse(res.RawResponse))
		return
	}
	data.RefreshFromSharedAppStoreAppSettingsOutput(res.AppStoreAppSettingsOutput)
	refreshPlan(ctx, plan, &data, resp.Diagnostics)
	appID := data.AppID.ValueString()
	request1 := operations.GetAppStoreAppRequest{
		AppID: appID,
	}
	res1, err := r.client.AppStore.GetAppStoreApp(ctx, request1)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res1 != nil && res1.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res1.RawResponse))
		}
		return
	}
	if res1 == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res1))
		return
	}
	if res1.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res1.StatusCode), debugResponse(res1.RawResponse))
		return
	}
	if !(res1.AppStoreApp != nil) {
		resp.Diagnostics.AddError("unexpected response from API. Got an unexpected response body", debugResponse(res1.RawResponse))
		return
	}
	data.RefreshFromSharedAppStoreApp(res1.AppStoreApp)
	refreshPlan(ctx, plan, &data, resp.Diagnostics)

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *AppStoreAppResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data *AppStoreAppResourceModel
	var item types.Object

	resp.Diagnostics.Append(req.State.Get(ctx, &item)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(item.As(ctx, &data, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)

	if resp.Diagnostics.HasError() {
		return
	}

	appID := data.AppID.ValueString()
	request := operations.GetAppStoreAppRequest{
		AppID: appID,
	}
	res, err := r.client.AppStore.GetAppStoreApp(ctx, request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode == 404 {
		resp.State.RemoveResource(ctx)
		return
	}
	if res.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}
	if !(res.AppStoreApp != nil) {
		resp.Diagnostics.AddError("unexpected response from API. Got an unexpected response body", debugResponse(res.RawResponse))
		return
	}
	data.RefreshFromSharedAppStoreApp(res.AppStoreApp)

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *AppStoreAppResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var data *AppStoreAppResourceModel
	var plan types.Object

	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	merge(ctx, req, resp, &data)
	if resp.Diagnostics.HasError() {
		return
	}

	// Not Implemented; all attributes marked as RequiresReplace

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *AppStoreAppResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data *AppStoreAppResourceModel
	var item types.Object

	resp.Diagnostics.Append(req.State.Get(ctx, &item)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(item.As(ctx, &data, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)

	if resp.Diagnostics.HasError() {
		return
	}

	appID := data.AppID.ValueString()
	request := operations.RemoveAppFromAppStoreRequest{
		AppID: appID,
	}
	res, err := r.client.AppStore.RemoveAppFromAppStore(ctx, request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}

}

func (r *AppStoreAppResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("app_id"), req.ID)...)
}
