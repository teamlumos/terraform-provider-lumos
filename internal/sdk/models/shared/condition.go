// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
// @generated-id: 56f72fe38174

package shared

import (
	"errors"
	"fmt"
	"github.com/teamlumos/terraform-provider-lumos/internal/sdk/internal/utils"
	"time"
)

type AttributeType string

const (
	AttributeTypeStr              AttributeType = "str"
	AttributeTypeAttributeOperand AttributeType = "AttributeOperand"
)

// Attribute operator. This operator specifies an attribute of one of the target entities in our evaluation context that we'd like to use in this condition.
type Attribute struct {
	Str              *string           `queryParam:"inline" union:"member"`
	AttributeOperand *AttributeOperand `queryParam:"inline" union:"member"`

	Type AttributeType
}

func CreateAttributeStr(str string) Attribute {
	typ := AttributeTypeStr

	return Attribute{
		Str:  &str,
		Type: typ,
	}
}

func CreateAttributeAttributeOperand(attributeOperand AttributeOperand) Attribute {
	typ := AttributeTypeAttributeOperand

	return Attribute{
		AttributeOperand: &attributeOperand,
		Type:             typ,
	}
}

func (u *Attribute) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  AttributeTypeStr,
			Value: &str,
		})
	}

	var attributeOperand AttributeOperand = AttributeOperand{}
	if err := utils.UnmarshalJSON(data, &attributeOperand, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  AttributeTypeAttributeOperand,
			Value: &attributeOperand,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for Attribute", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for Attribute", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(AttributeType)
	switch best.Type {
	case AttributeTypeStr:
		u.Str = best.Value.(*string)
		return nil
	case AttributeTypeAttributeOperand:
		u.AttributeOperand = best.Value.(*AttributeOperand)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for Attribute", string(data))
}

func (u Attribute) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.AttributeOperand != nil {
		return utils.MarshalJSON(u.AttributeOperand, "", true)
	}

	return nil, errors.New("could not marshal union type Attribute: all fields are null")
}

type EqualsType string

const (
	EqualsTypeInteger     EqualsType = "integer"
	EqualsTypeNumber      EqualsType = "number"
	EqualsTypeDateTime    EqualsType = "date-time"
	EqualsTypeBoolean     EqualsType = "boolean"
	EqualsTypeStr         EqualsType = "str"
	EqualsTypeValueOption EqualsType = "ValueOption"
)

// Equals - Equality operator.
type Equals struct {
	Integer     *int64       `queryParam:"inline" union:"member"`
	Number      *float64     `queryParam:"inline" union:"member"`
	DateTime    *time.Time   `queryParam:"inline" union:"member"`
	Boolean     *bool        `queryParam:"inline" union:"member"`
	Str         *string      `queryParam:"inline" union:"member"`
	ValueOption *ValueOption `queryParam:"inline" union:"member"`

	Type EqualsType
}

func CreateEqualsInteger(integer int64) Equals {
	typ := EqualsTypeInteger

	return Equals{
		Integer: &integer,
		Type:    typ,
	}
}

func CreateEqualsNumber(number float64) Equals {
	typ := EqualsTypeNumber

	return Equals{
		Number: &number,
		Type:   typ,
	}
}

func CreateEqualsDateTime(dateTime time.Time) Equals {
	typ := EqualsTypeDateTime

	return Equals{
		DateTime: &dateTime,
		Type:     typ,
	}
}

func CreateEqualsBoolean(boolean bool) Equals {
	typ := EqualsTypeBoolean

	return Equals{
		Boolean: &boolean,
		Type:    typ,
	}
}

func CreateEqualsStr(str string) Equals {
	typ := EqualsTypeStr

	return Equals{
		Str:  &str,
		Type: typ,
	}
}

func CreateEqualsValueOption(valueOption ValueOption) Equals {
	typ := EqualsTypeValueOption

	return Equals{
		ValueOption: &valueOption,
		Type:        typ,
	}
}

func (u *Equals) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var integer int64 = int64(0)
	if err := utils.UnmarshalJSON(data, &integer, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  EqualsTypeInteger,
			Value: &integer,
		})
	}

	var number float64 = float64(0)
	if err := utils.UnmarshalJSON(data, &number, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  EqualsTypeNumber,
			Value: &number,
		})
	}

	var dateTime time.Time = time.Time{}
	if err := utils.UnmarshalJSON(data, &dateTime, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  EqualsTypeDateTime,
			Value: &dateTime,
		})
	}

	var boolean bool = false
	if err := utils.UnmarshalJSON(data, &boolean, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  EqualsTypeBoolean,
			Value: &boolean,
		})
	}

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  EqualsTypeStr,
			Value: &str,
		})
	}

	var valueOption ValueOption = ValueOption{}
	if err := utils.UnmarshalJSON(data, &valueOption, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  EqualsTypeValueOption,
			Value: &valueOption,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for Equals", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for Equals", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(EqualsType)
	switch best.Type {
	case EqualsTypeInteger:
		u.Integer = best.Value.(*int64)
		return nil
	case EqualsTypeNumber:
		u.Number = best.Value.(*float64)
		return nil
	case EqualsTypeDateTime:
		u.DateTime = best.Value.(*time.Time)
		return nil
	case EqualsTypeBoolean:
		u.Boolean = best.Value.(*bool)
		return nil
	case EqualsTypeStr:
		u.Str = best.Value.(*string)
		return nil
	case EqualsTypeValueOption:
		u.ValueOption = best.Value.(*ValueOption)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for Equals", string(data))
}

func (u Equals) MarshalJSON() ([]byte, error) {
	if u.Integer != nil {
		return utils.MarshalJSON(u.Integer, "", true)
	}

	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	if u.DateTime != nil {
		return utils.MarshalJSON(u.DateTime, "", true)
	}

	if u.Boolean != nil {
		return utils.MarshalJSON(u.Boolean, "", true)
	}

	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.ValueOption != nil {
		return utils.MarshalJSON(u.ValueOption, "", true)
	}

	return nil, errors.New("could not marshal union type Equals: all fields are null")
}

type NotEqualType string

const (
	NotEqualTypeInteger     NotEqualType = "integer"
	NotEqualTypeNumber      NotEqualType = "number"
	NotEqualTypeDateTime    NotEqualType = "date-time"
	NotEqualTypeBoolean     NotEqualType = "boolean"
	NotEqualTypeStr         NotEqualType = "str"
	NotEqualTypeValueOption NotEqualType = "ValueOption"
)

// NotEqual - Not equal to operator.
type NotEqual struct {
	Integer     *int64       `queryParam:"inline" union:"member"`
	Number      *float64     `queryParam:"inline" union:"member"`
	DateTime    *time.Time   `queryParam:"inline" union:"member"`
	Boolean     *bool        `queryParam:"inline" union:"member"`
	Str         *string      `queryParam:"inline" union:"member"`
	ValueOption *ValueOption `queryParam:"inline" union:"member"`

	Type NotEqualType
}

func CreateNotEqualInteger(integer int64) NotEqual {
	typ := NotEqualTypeInteger

	return NotEqual{
		Integer: &integer,
		Type:    typ,
	}
}

func CreateNotEqualNumber(number float64) NotEqual {
	typ := NotEqualTypeNumber

	return NotEqual{
		Number: &number,
		Type:   typ,
	}
}

func CreateNotEqualDateTime(dateTime time.Time) NotEqual {
	typ := NotEqualTypeDateTime

	return NotEqual{
		DateTime: &dateTime,
		Type:     typ,
	}
}

func CreateNotEqualBoolean(boolean bool) NotEqual {
	typ := NotEqualTypeBoolean

	return NotEqual{
		Boolean: &boolean,
		Type:    typ,
	}
}

func CreateNotEqualStr(str string) NotEqual {
	typ := NotEqualTypeStr

	return NotEqual{
		Str:  &str,
		Type: typ,
	}
}

func CreateNotEqualValueOption(valueOption ValueOption) NotEqual {
	typ := NotEqualTypeValueOption

	return NotEqual{
		ValueOption: &valueOption,
		Type:        typ,
	}
}

func (u *NotEqual) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var integer int64 = int64(0)
	if err := utils.UnmarshalJSON(data, &integer, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  NotEqualTypeInteger,
			Value: &integer,
		})
	}

	var number float64 = float64(0)
	if err := utils.UnmarshalJSON(data, &number, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  NotEqualTypeNumber,
			Value: &number,
		})
	}

	var dateTime time.Time = time.Time{}
	if err := utils.UnmarshalJSON(data, &dateTime, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  NotEqualTypeDateTime,
			Value: &dateTime,
		})
	}

	var boolean bool = false
	if err := utils.UnmarshalJSON(data, &boolean, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  NotEqualTypeBoolean,
			Value: &boolean,
		})
	}

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  NotEqualTypeStr,
			Value: &str,
		})
	}

	var valueOption ValueOption = ValueOption{}
	if err := utils.UnmarshalJSON(data, &valueOption, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  NotEqualTypeValueOption,
			Value: &valueOption,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for NotEqual", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for NotEqual", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(NotEqualType)
	switch best.Type {
	case NotEqualTypeInteger:
		u.Integer = best.Value.(*int64)
		return nil
	case NotEqualTypeNumber:
		u.Number = best.Value.(*float64)
		return nil
	case NotEqualTypeDateTime:
		u.DateTime = best.Value.(*time.Time)
		return nil
	case NotEqualTypeBoolean:
		u.Boolean = best.Value.(*bool)
		return nil
	case NotEqualTypeStr:
		u.Str = best.Value.(*string)
		return nil
	case NotEqualTypeValueOption:
		u.ValueOption = best.Value.(*ValueOption)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for NotEqual", string(data))
}

func (u NotEqual) MarshalJSON() ([]byte, error) {
	if u.Integer != nil {
		return utils.MarshalJSON(u.Integer, "", true)
	}

	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	if u.DateTime != nil {
		return utils.MarshalJSON(u.DateTime, "", true)
	}

	if u.Boolean != nil {
		return utils.MarshalJSON(u.Boolean, "", true)
	}

	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.ValueOption != nil {
		return utils.MarshalJSON(u.ValueOption, "", true)
	}

	return nil, errors.New("could not marshal union type NotEqual: all fields are null")
}

type OneType string

const (
	OneTypeInteger  OneType = "integer"
	OneTypeNumber   OneType = "number"
	OneTypeDateTime OneType = "date-time"
	OneTypeBoolean  OneType = "boolean"
	OneTypeStr      OneType = "str"
)

type One struct {
	Integer  *int64     `queryParam:"inline" union:"member"`
	Number   *float64   `queryParam:"inline" union:"member"`
	DateTime *time.Time `queryParam:"inline" union:"member"`
	Boolean  *bool      `queryParam:"inline" union:"member"`
	Str      *string    `queryParam:"inline" union:"member"`

	Type OneType
}

func CreateOneInteger(integer int64) One {
	typ := OneTypeInteger

	return One{
		Integer: &integer,
		Type:    typ,
	}
}

func CreateOneNumber(number float64) One {
	typ := OneTypeNumber

	return One{
		Number: &number,
		Type:   typ,
	}
}

func CreateOneDateTime(dateTime time.Time) One {
	typ := OneTypeDateTime

	return One{
		DateTime: &dateTime,
		Type:     typ,
	}
}

func CreateOneBoolean(boolean bool) One {
	typ := OneTypeBoolean

	return One{
		Boolean: &boolean,
		Type:    typ,
	}
}

func CreateOneStr(str string) One {
	typ := OneTypeStr

	return One{
		Str:  &str,
		Type: typ,
	}
}

func (u *One) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var integer int64 = int64(0)
	if err := utils.UnmarshalJSON(data, &integer, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  OneTypeInteger,
			Value: &integer,
		})
	}

	var number float64 = float64(0)
	if err := utils.UnmarshalJSON(data, &number, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  OneTypeNumber,
			Value: &number,
		})
	}

	var dateTime time.Time = time.Time{}
	if err := utils.UnmarshalJSON(data, &dateTime, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  OneTypeDateTime,
			Value: &dateTime,
		})
	}

	var boolean bool = false
	if err := utils.UnmarshalJSON(data, &boolean, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  OneTypeBoolean,
			Value: &boolean,
		})
	}

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  OneTypeStr,
			Value: &str,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for One", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for One", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(OneType)
	switch best.Type {
	case OneTypeInteger:
		u.Integer = best.Value.(*int64)
		return nil
	case OneTypeNumber:
		u.Number = best.Value.(*float64)
		return nil
	case OneTypeDateTime:
		u.DateTime = best.Value.(*time.Time)
		return nil
	case OneTypeBoolean:
		u.Boolean = best.Value.(*bool)
		return nil
	case OneTypeStr:
		u.Str = best.Value.(*string)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for One", string(data))
}

func (u One) MarshalJSON() ([]byte, error) {
	if u.Integer != nil {
		return utils.MarshalJSON(u.Integer, "", true)
	}

	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	if u.DateTime != nil {
		return utils.MarshalJSON(u.DateTime, "", true)
	}

	if u.Boolean != nil {
		return utils.MarshalJSON(u.Boolean, "", true)
	}

	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	return nil, errors.New("could not marshal union type One: all fields are null")
}

type InType string

const (
	InTypeArrayOf1           InType = "arrayOf1"
	InTypeArrayOfValueOption InType = "arrayOfValueOption"
	InTypeInteger            InType = "integer"
	InTypeNumber             InType = "number"
	InTypeDateTime           InType = "date-time"
	InTypeBoolean            InType = "boolean"
	InTypeStr                InType = "str"
	InTypeValueOption        InType = "ValueOption"
)

// In - IN operator - checks if the attribute is in the list. When applied to a string, checks if the value on the left-hand-side of the condition is a substring of this value.
type In struct {
	ArrayOf1           []One         `queryParam:"inline" union:"member"`
	ArrayOfValueOption []ValueOption `queryParam:"inline" union:"member"`
	Integer            *int64        `queryParam:"inline" union:"member"`
	Number             *float64      `queryParam:"inline" union:"member"`
	DateTime           *time.Time    `queryParam:"inline" union:"member"`
	Boolean            *bool         `queryParam:"inline" union:"member"`
	Str                *string       `queryParam:"inline" union:"member"`
	ValueOption        *ValueOption  `queryParam:"inline" union:"member"`

	Type InType
}

func CreateInArrayOf1(arrayOf1 []One) In {
	typ := InTypeArrayOf1

	return In{
		ArrayOf1: arrayOf1,
		Type:     typ,
	}
}

func CreateInArrayOfValueOption(arrayOfValueOption []ValueOption) In {
	typ := InTypeArrayOfValueOption

	return In{
		ArrayOfValueOption: arrayOfValueOption,
		Type:               typ,
	}
}

func CreateInInteger(integer int64) In {
	typ := InTypeInteger

	return In{
		Integer: &integer,
		Type:    typ,
	}
}

func CreateInNumber(number float64) In {
	typ := InTypeNumber

	return In{
		Number: &number,
		Type:   typ,
	}
}

func CreateInDateTime(dateTime time.Time) In {
	typ := InTypeDateTime

	return In{
		DateTime: &dateTime,
		Type:     typ,
	}
}

func CreateInBoolean(boolean bool) In {
	typ := InTypeBoolean

	return In{
		Boolean: &boolean,
		Type:    typ,
	}
}

func CreateInStr(str string) In {
	typ := InTypeStr

	return In{
		Str:  &str,
		Type: typ,
	}
}

func CreateInValueOption(valueOption ValueOption) In {
	typ := InTypeValueOption

	return In{
		ValueOption: &valueOption,
		Type:        typ,
	}
}

func (u *In) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var arrayOf1 []One = []One{}
	if err := utils.UnmarshalJSON(data, &arrayOf1, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  InTypeArrayOf1,
			Value: arrayOf1,
		})
	}

	var arrayOfValueOption []ValueOption = []ValueOption{}
	if err := utils.UnmarshalJSON(data, &arrayOfValueOption, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  InTypeArrayOfValueOption,
			Value: arrayOfValueOption,
		})
	}

	var integer int64 = int64(0)
	if err := utils.UnmarshalJSON(data, &integer, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  InTypeInteger,
			Value: &integer,
		})
	}

	var number float64 = float64(0)
	if err := utils.UnmarshalJSON(data, &number, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  InTypeNumber,
			Value: &number,
		})
	}

	var dateTime time.Time = time.Time{}
	if err := utils.UnmarshalJSON(data, &dateTime, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  InTypeDateTime,
			Value: &dateTime,
		})
	}

	var boolean bool = false
	if err := utils.UnmarshalJSON(data, &boolean, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  InTypeBoolean,
			Value: &boolean,
		})
	}

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  InTypeStr,
			Value: &str,
		})
	}

	var valueOption ValueOption = ValueOption{}
	if err := utils.UnmarshalJSON(data, &valueOption, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  InTypeValueOption,
			Value: &valueOption,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for In", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for In", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(InType)
	switch best.Type {
	case InTypeArrayOf1:
		u.ArrayOf1 = best.Value.([]One)
		return nil
	case InTypeArrayOfValueOption:
		u.ArrayOfValueOption = best.Value.([]ValueOption)
		return nil
	case InTypeInteger:
		u.Integer = best.Value.(*int64)
		return nil
	case InTypeNumber:
		u.Number = best.Value.(*float64)
		return nil
	case InTypeDateTime:
		u.DateTime = best.Value.(*time.Time)
		return nil
	case InTypeBoolean:
		u.Boolean = best.Value.(*bool)
		return nil
	case InTypeStr:
		u.Str = best.Value.(*string)
		return nil
	case InTypeValueOption:
		u.ValueOption = best.Value.(*ValueOption)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for In", string(data))
}

func (u In) MarshalJSON() ([]byte, error) {
	if u.ArrayOf1 != nil {
		return utils.MarshalJSON(u.ArrayOf1, "", true)
	}

	if u.ArrayOfValueOption != nil {
		return utils.MarshalJSON(u.ArrayOfValueOption, "", true)
	}

	if u.Integer != nil {
		return utils.MarshalJSON(u.Integer, "", true)
	}

	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	if u.DateTime != nil {
		return utils.MarshalJSON(u.DateTime, "", true)
	}

	if u.Boolean != nil {
		return utils.MarshalJSON(u.Boolean, "", true)
	}

	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.ValueOption != nil {
		return utils.MarshalJSON(u.ValueOption, "", true)
	}

	return nil, errors.New("could not marshal union type In: all fields are null")
}

type GreaterThanType string

const (
	GreaterThanTypeInteger     GreaterThanType = "integer"
	GreaterThanTypeNumber      GreaterThanType = "number"
	GreaterThanTypeDateTime    GreaterThanType = "date-time"
	GreaterThanTypeBoolean     GreaterThanType = "boolean"
	GreaterThanTypeStr         GreaterThanType = "str"
	GreaterThanTypeValueOption GreaterThanType = "ValueOption"
)

// GreaterThan - Greater than operator.
type GreaterThan struct {
	Integer     *int64       `queryParam:"inline" union:"member"`
	Number      *float64     `queryParam:"inline" union:"member"`
	DateTime    *time.Time   `queryParam:"inline" union:"member"`
	Boolean     *bool        `queryParam:"inline" union:"member"`
	Str         *string      `queryParam:"inline" union:"member"`
	ValueOption *ValueOption `queryParam:"inline" union:"member"`

	Type GreaterThanType
}

func CreateGreaterThanInteger(integer int64) GreaterThan {
	typ := GreaterThanTypeInteger

	return GreaterThan{
		Integer: &integer,
		Type:    typ,
	}
}

func CreateGreaterThanNumber(number float64) GreaterThan {
	typ := GreaterThanTypeNumber

	return GreaterThan{
		Number: &number,
		Type:   typ,
	}
}

func CreateGreaterThanDateTime(dateTime time.Time) GreaterThan {
	typ := GreaterThanTypeDateTime

	return GreaterThan{
		DateTime: &dateTime,
		Type:     typ,
	}
}

func CreateGreaterThanBoolean(boolean bool) GreaterThan {
	typ := GreaterThanTypeBoolean

	return GreaterThan{
		Boolean: &boolean,
		Type:    typ,
	}
}

func CreateGreaterThanStr(str string) GreaterThan {
	typ := GreaterThanTypeStr

	return GreaterThan{
		Str:  &str,
		Type: typ,
	}
}

func CreateGreaterThanValueOption(valueOption ValueOption) GreaterThan {
	typ := GreaterThanTypeValueOption

	return GreaterThan{
		ValueOption: &valueOption,
		Type:        typ,
	}
}

func (u *GreaterThan) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var integer int64 = int64(0)
	if err := utils.UnmarshalJSON(data, &integer, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  GreaterThanTypeInteger,
			Value: &integer,
		})
	}

	var number float64 = float64(0)
	if err := utils.UnmarshalJSON(data, &number, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  GreaterThanTypeNumber,
			Value: &number,
		})
	}

	var dateTime time.Time = time.Time{}
	if err := utils.UnmarshalJSON(data, &dateTime, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  GreaterThanTypeDateTime,
			Value: &dateTime,
		})
	}

	var boolean bool = false
	if err := utils.UnmarshalJSON(data, &boolean, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  GreaterThanTypeBoolean,
			Value: &boolean,
		})
	}

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  GreaterThanTypeStr,
			Value: &str,
		})
	}

	var valueOption ValueOption = ValueOption{}
	if err := utils.UnmarshalJSON(data, &valueOption, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  GreaterThanTypeValueOption,
			Value: &valueOption,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for GreaterThan", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for GreaterThan", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(GreaterThanType)
	switch best.Type {
	case GreaterThanTypeInteger:
		u.Integer = best.Value.(*int64)
		return nil
	case GreaterThanTypeNumber:
		u.Number = best.Value.(*float64)
		return nil
	case GreaterThanTypeDateTime:
		u.DateTime = best.Value.(*time.Time)
		return nil
	case GreaterThanTypeBoolean:
		u.Boolean = best.Value.(*bool)
		return nil
	case GreaterThanTypeStr:
		u.Str = best.Value.(*string)
		return nil
	case GreaterThanTypeValueOption:
		u.ValueOption = best.Value.(*ValueOption)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for GreaterThan", string(data))
}

func (u GreaterThan) MarshalJSON() ([]byte, error) {
	if u.Integer != nil {
		return utils.MarshalJSON(u.Integer, "", true)
	}

	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	if u.DateTime != nil {
		return utils.MarshalJSON(u.DateTime, "", true)
	}

	if u.Boolean != nil {
		return utils.MarshalJSON(u.Boolean, "", true)
	}

	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.ValueOption != nil {
		return utils.MarshalJSON(u.ValueOption, "", true)
	}

	return nil, errors.New("could not marshal union type GreaterThan: all fields are null")
}

type GreaterThanEqualType string

const (
	GreaterThanEqualTypeInteger     GreaterThanEqualType = "integer"
	GreaterThanEqualTypeNumber      GreaterThanEqualType = "number"
	GreaterThanEqualTypeDateTime    GreaterThanEqualType = "date-time"
	GreaterThanEqualTypeBoolean     GreaterThanEqualType = "boolean"
	GreaterThanEqualTypeStr         GreaterThanEqualType = "str"
	GreaterThanEqualTypeValueOption GreaterThanEqualType = "ValueOption"
)

// GreaterThanEqual - Greater than or equal to operator.
type GreaterThanEqual struct {
	Integer     *int64       `queryParam:"inline" union:"member"`
	Number      *float64     `queryParam:"inline" union:"member"`
	DateTime    *time.Time   `queryParam:"inline" union:"member"`
	Boolean     *bool        `queryParam:"inline" union:"member"`
	Str         *string      `queryParam:"inline" union:"member"`
	ValueOption *ValueOption `queryParam:"inline" union:"member"`

	Type GreaterThanEqualType
}

func CreateGreaterThanEqualInteger(integer int64) GreaterThanEqual {
	typ := GreaterThanEqualTypeInteger

	return GreaterThanEqual{
		Integer: &integer,
		Type:    typ,
	}
}

func CreateGreaterThanEqualNumber(number float64) GreaterThanEqual {
	typ := GreaterThanEqualTypeNumber

	return GreaterThanEqual{
		Number: &number,
		Type:   typ,
	}
}

func CreateGreaterThanEqualDateTime(dateTime time.Time) GreaterThanEqual {
	typ := GreaterThanEqualTypeDateTime

	return GreaterThanEqual{
		DateTime: &dateTime,
		Type:     typ,
	}
}

func CreateGreaterThanEqualBoolean(boolean bool) GreaterThanEqual {
	typ := GreaterThanEqualTypeBoolean

	return GreaterThanEqual{
		Boolean: &boolean,
		Type:    typ,
	}
}

func CreateGreaterThanEqualStr(str string) GreaterThanEqual {
	typ := GreaterThanEqualTypeStr

	return GreaterThanEqual{
		Str:  &str,
		Type: typ,
	}
}

func CreateGreaterThanEqualValueOption(valueOption ValueOption) GreaterThanEqual {
	typ := GreaterThanEqualTypeValueOption

	return GreaterThanEqual{
		ValueOption: &valueOption,
		Type:        typ,
	}
}

func (u *GreaterThanEqual) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var integer int64 = int64(0)
	if err := utils.UnmarshalJSON(data, &integer, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  GreaterThanEqualTypeInteger,
			Value: &integer,
		})
	}

	var number float64 = float64(0)
	if err := utils.UnmarshalJSON(data, &number, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  GreaterThanEqualTypeNumber,
			Value: &number,
		})
	}

	var dateTime time.Time = time.Time{}
	if err := utils.UnmarshalJSON(data, &dateTime, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  GreaterThanEqualTypeDateTime,
			Value: &dateTime,
		})
	}

	var boolean bool = false
	if err := utils.UnmarshalJSON(data, &boolean, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  GreaterThanEqualTypeBoolean,
			Value: &boolean,
		})
	}

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  GreaterThanEqualTypeStr,
			Value: &str,
		})
	}

	var valueOption ValueOption = ValueOption{}
	if err := utils.UnmarshalJSON(data, &valueOption, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  GreaterThanEqualTypeValueOption,
			Value: &valueOption,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for GreaterThanEqual", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for GreaterThanEqual", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(GreaterThanEqualType)
	switch best.Type {
	case GreaterThanEqualTypeInteger:
		u.Integer = best.Value.(*int64)
		return nil
	case GreaterThanEqualTypeNumber:
		u.Number = best.Value.(*float64)
		return nil
	case GreaterThanEqualTypeDateTime:
		u.DateTime = best.Value.(*time.Time)
		return nil
	case GreaterThanEqualTypeBoolean:
		u.Boolean = best.Value.(*bool)
		return nil
	case GreaterThanEqualTypeStr:
		u.Str = best.Value.(*string)
		return nil
	case GreaterThanEqualTypeValueOption:
		u.ValueOption = best.Value.(*ValueOption)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for GreaterThanEqual", string(data))
}

func (u GreaterThanEqual) MarshalJSON() ([]byte, error) {
	if u.Integer != nil {
		return utils.MarshalJSON(u.Integer, "", true)
	}

	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	if u.DateTime != nil {
		return utils.MarshalJSON(u.DateTime, "", true)
	}

	if u.Boolean != nil {
		return utils.MarshalJSON(u.Boolean, "", true)
	}

	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.ValueOption != nil {
		return utils.MarshalJSON(u.ValueOption, "", true)
	}

	return nil, errors.New("could not marshal union type GreaterThanEqual: all fields are null")
}

type LessThanType string

const (
	LessThanTypeInteger     LessThanType = "integer"
	LessThanTypeNumber      LessThanType = "number"
	LessThanTypeDateTime    LessThanType = "date-time"
	LessThanTypeBoolean     LessThanType = "boolean"
	LessThanTypeStr         LessThanType = "str"
	LessThanTypeValueOption LessThanType = "ValueOption"
)

// LessThan - Less than operator.
type LessThan struct {
	Integer     *int64       `queryParam:"inline" union:"member"`
	Number      *float64     `queryParam:"inline" union:"member"`
	DateTime    *time.Time   `queryParam:"inline" union:"member"`
	Boolean     *bool        `queryParam:"inline" union:"member"`
	Str         *string      `queryParam:"inline" union:"member"`
	ValueOption *ValueOption `queryParam:"inline" union:"member"`

	Type LessThanType
}

func CreateLessThanInteger(integer int64) LessThan {
	typ := LessThanTypeInteger

	return LessThan{
		Integer: &integer,
		Type:    typ,
	}
}

func CreateLessThanNumber(number float64) LessThan {
	typ := LessThanTypeNumber

	return LessThan{
		Number: &number,
		Type:   typ,
	}
}

func CreateLessThanDateTime(dateTime time.Time) LessThan {
	typ := LessThanTypeDateTime

	return LessThan{
		DateTime: &dateTime,
		Type:     typ,
	}
}

func CreateLessThanBoolean(boolean bool) LessThan {
	typ := LessThanTypeBoolean

	return LessThan{
		Boolean: &boolean,
		Type:    typ,
	}
}

func CreateLessThanStr(str string) LessThan {
	typ := LessThanTypeStr

	return LessThan{
		Str:  &str,
		Type: typ,
	}
}

func CreateLessThanValueOption(valueOption ValueOption) LessThan {
	typ := LessThanTypeValueOption

	return LessThan{
		ValueOption: &valueOption,
		Type:        typ,
	}
}

func (u *LessThan) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var integer int64 = int64(0)
	if err := utils.UnmarshalJSON(data, &integer, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  LessThanTypeInteger,
			Value: &integer,
		})
	}

	var number float64 = float64(0)
	if err := utils.UnmarshalJSON(data, &number, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  LessThanTypeNumber,
			Value: &number,
		})
	}

	var dateTime time.Time = time.Time{}
	if err := utils.UnmarshalJSON(data, &dateTime, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  LessThanTypeDateTime,
			Value: &dateTime,
		})
	}

	var boolean bool = false
	if err := utils.UnmarshalJSON(data, &boolean, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  LessThanTypeBoolean,
			Value: &boolean,
		})
	}

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  LessThanTypeStr,
			Value: &str,
		})
	}

	var valueOption ValueOption = ValueOption{}
	if err := utils.UnmarshalJSON(data, &valueOption, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  LessThanTypeValueOption,
			Value: &valueOption,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for LessThan", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for LessThan", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(LessThanType)
	switch best.Type {
	case LessThanTypeInteger:
		u.Integer = best.Value.(*int64)
		return nil
	case LessThanTypeNumber:
		u.Number = best.Value.(*float64)
		return nil
	case LessThanTypeDateTime:
		u.DateTime = best.Value.(*time.Time)
		return nil
	case LessThanTypeBoolean:
		u.Boolean = best.Value.(*bool)
		return nil
	case LessThanTypeStr:
		u.Str = best.Value.(*string)
		return nil
	case LessThanTypeValueOption:
		u.ValueOption = best.Value.(*ValueOption)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for LessThan", string(data))
}

func (u LessThan) MarshalJSON() ([]byte, error) {
	if u.Integer != nil {
		return utils.MarshalJSON(u.Integer, "", true)
	}

	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	if u.DateTime != nil {
		return utils.MarshalJSON(u.DateTime, "", true)
	}

	if u.Boolean != nil {
		return utils.MarshalJSON(u.Boolean, "", true)
	}

	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.ValueOption != nil {
		return utils.MarshalJSON(u.ValueOption, "", true)
	}

	return nil, errors.New("could not marshal union type LessThan: all fields are null")
}

type LessThanEqualType string

const (
	LessThanEqualTypeInteger     LessThanEqualType = "integer"
	LessThanEqualTypeNumber      LessThanEqualType = "number"
	LessThanEqualTypeDateTime    LessThanEqualType = "date-time"
	LessThanEqualTypeBoolean     LessThanEqualType = "boolean"
	LessThanEqualTypeStr         LessThanEqualType = "str"
	LessThanEqualTypeValueOption LessThanEqualType = "ValueOption"
)

// LessThanEqual - Less than or equal to operator.
type LessThanEqual struct {
	Integer     *int64       `queryParam:"inline" union:"member"`
	Number      *float64     `queryParam:"inline" union:"member"`
	DateTime    *time.Time   `queryParam:"inline" union:"member"`
	Boolean     *bool        `queryParam:"inline" union:"member"`
	Str         *string      `queryParam:"inline" union:"member"`
	ValueOption *ValueOption `queryParam:"inline" union:"member"`

	Type LessThanEqualType
}

func CreateLessThanEqualInteger(integer int64) LessThanEqual {
	typ := LessThanEqualTypeInteger

	return LessThanEqual{
		Integer: &integer,
		Type:    typ,
	}
}

func CreateLessThanEqualNumber(number float64) LessThanEqual {
	typ := LessThanEqualTypeNumber

	return LessThanEqual{
		Number: &number,
		Type:   typ,
	}
}

func CreateLessThanEqualDateTime(dateTime time.Time) LessThanEqual {
	typ := LessThanEqualTypeDateTime

	return LessThanEqual{
		DateTime: &dateTime,
		Type:     typ,
	}
}

func CreateLessThanEqualBoolean(boolean bool) LessThanEqual {
	typ := LessThanEqualTypeBoolean

	return LessThanEqual{
		Boolean: &boolean,
		Type:    typ,
	}
}

func CreateLessThanEqualStr(str string) LessThanEqual {
	typ := LessThanEqualTypeStr

	return LessThanEqual{
		Str:  &str,
		Type: typ,
	}
}

func CreateLessThanEqualValueOption(valueOption ValueOption) LessThanEqual {
	typ := LessThanEqualTypeValueOption

	return LessThanEqual{
		ValueOption: &valueOption,
		Type:        typ,
	}
}

func (u *LessThanEqual) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var integer int64 = int64(0)
	if err := utils.UnmarshalJSON(data, &integer, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  LessThanEqualTypeInteger,
			Value: &integer,
		})
	}

	var number float64 = float64(0)
	if err := utils.UnmarshalJSON(data, &number, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  LessThanEqualTypeNumber,
			Value: &number,
		})
	}

	var dateTime time.Time = time.Time{}
	if err := utils.UnmarshalJSON(data, &dateTime, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  LessThanEqualTypeDateTime,
			Value: &dateTime,
		})
	}

	var boolean bool = false
	if err := utils.UnmarshalJSON(data, &boolean, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  LessThanEqualTypeBoolean,
			Value: &boolean,
		})
	}

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  LessThanEqualTypeStr,
			Value: &str,
		})
	}

	var valueOption ValueOption = ValueOption{}
	if err := utils.UnmarshalJSON(data, &valueOption, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  LessThanEqualTypeValueOption,
			Value: &valueOption,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for LessThanEqual", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for LessThanEqual", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(LessThanEqualType)
	switch best.Type {
	case LessThanEqualTypeInteger:
		u.Integer = best.Value.(*int64)
		return nil
	case LessThanEqualTypeNumber:
		u.Number = best.Value.(*float64)
		return nil
	case LessThanEqualTypeDateTime:
		u.DateTime = best.Value.(*time.Time)
		return nil
	case LessThanEqualTypeBoolean:
		u.Boolean = best.Value.(*bool)
		return nil
	case LessThanEqualTypeStr:
		u.Str = best.Value.(*string)
		return nil
	case LessThanEqualTypeValueOption:
		u.ValueOption = best.Value.(*ValueOption)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for LessThanEqual", string(data))
}

func (u LessThanEqual) MarshalJSON() ([]byte, error) {
	if u.Integer != nil {
		return utils.MarshalJSON(u.Integer, "", true)
	}

	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	if u.DateTime != nil {
		return utils.MarshalJSON(u.DateTime, "", true)
	}

	if u.Boolean != nil {
		return utils.MarshalJSON(u.Boolean, "", true)
	}

	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.ValueOption != nil {
		return utils.MarshalJSON(u.ValueOption, "", true)
	}

	return nil, errors.New("could not marshal union type LessThanEqual: all fields are null")
}

type ContainsType string

const (
	ContainsTypeInteger     ContainsType = "integer"
	ContainsTypeNumber      ContainsType = "number"
	ContainsTypeDateTime    ContainsType = "date-time"
	ContainsTypeBoolean     ContainsType = "boolean"
	ContainsTypeStr         ContainsType = "str"
	ContainsTypeValueOption ContainsType = "ValueOption"
)

// Contains operator - checks if the attribute contains the value.
type Contains struct {
	Integer     *int64       `queryParam:"inline" union:"member"`
	Number      *float64     `queryParam:"inline" union:"member"`
	DateTime    *time.Time   `queryParam:"inline" union:"member"`
	Boolean     *bool        `queryParam:"inline" union:"member"`
	Str         *string      `queryParam:"inline" union:"member"`
	ValueOption *ValueOption `queryParam:"inline" union:"member"`

	Type ContainsType
}

func CreateContainsInteger(integer int64) Contains {
	typ := ContainsTypeInteger

	return Contains{
		Integer: &integer,
		Type:    typ,
	}
}

func CreateContainsNumber(number float64) Contains {
	typ := ContainsTypeNumber

	return Contains{
		Number: &number,
		Type:   typ,
	}
}

func CreateContainsDateTime(dateTime time.Time) Contains {
	typ := ContainsTypeDateTime

	return Contains{
		DateTime: &dateTime,
		Type:     typ,
	}
}

func CreateContainsBoolean(boolean bool) Contains {
	typ := ContainsTypeBoolean

	return Contains{
		Boolean: &boolean,
		Type:    typ,
	}
}

func CreateContainsStr(str string) Contains {
	typ := ContainsTypeStr

	return Contains{
		Str:  &str,
		Type: typ,
	}
}

func CreateContainsValueOption(valueOption ValueOption) Contains {
	typ := ContainsTypeValueOption

	return Contains{
		ValueOption: &valueOption,
		Type:        typ,
	}
}

func (u *Contains) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var integer int64 = int64(0)
	if err := utils.UnmarshalJSON(data, &integer, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  ContainsTypeInteger,
			Value: &integer,
		})
	}

	var number float64 = float64(0)
	if err := utils.UnmarshalJSON(data, &number, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  ContainsTypeNumber,
			Value: &number,
		})
	}

	var dateTime time.Time = time.Time{}
	if err := utils.UnmarshalJSON(data, &dateTime, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  ContainsTypeDateTime,
			Value: &dateTime,
		})
	}

	var boolean bool = false
	if err := utils.UnmarshalJSON(data, &boolean, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  ContainsTypeBoolean,
			Value: &boolean,
		})
	}

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  ContainsTypeStr,
			Value: &str,
		})
	}

	var valueOption ValueOption = ValueOption{}
	if err := utils.UnmarshalJSON(data, &valueOption, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  ContainsTypeValueOption,
			Value: &valueOption,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for Contains", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for Contains", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(ContainsType)
	switch best.Type {
	case ContainsTypeInteger:
		u.Integer = best.Value.(*int64)
		return nil
	case ContainsTypeNumber:
		u.Number = best.Value.(*float64)
		return nil
	case ContainsTypeDateTime:
		u.DateTime = best.Value.(*time.Time)
		return nil
	case ContainsTypeBoolean:
		u.Boolean = best.Value.(*bool)
		return nil
	case ContainsTypeStr:
		u.Str = best.Value.(*string)
		return nil
	case ContainsTypeValueOption:
		u.ValueOption = best.Value.(*ValueOption)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for Contains", string(data))
}

func (u Contains) MarshalJSON() ([]byte, error) {
	if u.Integer != nil {
		return utils.MarshalJSON(u.Integer, "", true)
	}

	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	if u.DateTime != nil {
		return utils.MarshalJSON(u.DateTime, "", true)
	}

	if u.Boolean != nil {
		return utils.MarshalJSON(u.Boolean, "", true)
	}

	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.ValueOption != nil {
		return utils.MarshalJSON(u.ValueOption, "", true)
	}

	return nil, errors.New("could not marshal union type Contains: all fields are null")
}

type ContainsAnyType string

const (
	ContainsAnyTypeInteger  ContainsAnyType = "integer"
	ContainsAnyTypeNumber   ContainsAnyType = "number"
	ContainsAnyTypeDateTime ContainsAnyType = "date-time"
	ContainsAnyTypeBoolean  ContainsAnyType = "boolean"
	ContainsAnyTypeStr      ContainsAnyType = "str"
)

type ContainsAny struct {
	Integer  *int64     `queryParam:"inline" union:"member"`
	Number   *float64   `queryParam:"inline" union:"member"`
	DateTime *time.Time `queryParam:"inline" union:"member"`
	Boolean  *bool      `queryParam:"inline" union:"member"`
	Str      *string    `queryParam:"inline" union:"member"`

	Type ContainsAnyType
}

func CreateContainsAnyInteger(integer int64) ContainsAny {
	typ := ContainsAnyTypeInteger

	return ContainsAny{
		Integer: &integer,
		Type:    typ,
	}
}

func CreateContainsAnyNumber(number float64) ContainsAny {
	typ := ContainsAnyTypeNumber

	return ContainsAny{
		Number: &number,
		Type:   typ,
	}
}

func CreateContainsAnyDateTime(dateTime time.Time) ContainsAny {
	typ := ContainsAnyTypeDateTime

	return ContainsAny{
		DateTime: &dateTime,
		Type:     typ,
	}
}

func CreateContainsAnyBoolean(boolean bool) ContainsAny {
	typ := ContainsAnyTypeBoolean

	return ContainsAny{
		Boolean: &boolean,
		Type:    typ,
	}
}

func CreateContainsAnyStr(str string) ContainsAny {
	typ := ContainsAnyTypeStr

	return ContainsAny{
		Str:  &str,
		Type: typ,
	}
}

func (u *ContainsAny) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var integer int64 = int64(0)
	if err := utils.UnmarshalJSON(data, &integer, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  ContainsAnyTypeInteger,
			Value: &integer,
		})
	}

	var number float64 = float64(0)
	if err := utils.UnmarshalJSON(data, &number, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  ContainsAnyTypeNumber,
			Value: &number,
		})
	}

	var dateTime time.Time = time.Time{}
	if err := utils.UnmarshalJSON(data, &dateTime, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  ContainsAnyTypeDateTime,
			Value: &dateTime,
		})
	}

	var boolean bool = false
	if err := utils.UnmarshalJSON(data, &boolean, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  ContainsAnyTypeBoolean,
			Value: &boolean,
		})
	}

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  ContainsAnyTypeStr,
			Value: &str,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for ContainsAny", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for ContainsAny", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(ContainsAnyType)
	switch best.Type {
	case ContainsAnyTypeInteger:
		u.Integer = best.Value.(*int64)
		return nil
	case ContainsAnyTypeNumber:
		u.Number = best.Value.(*float64)
		return nil
	case ContainsAnyTypeDateTime:
		u.DateTime = best.Value.(*time.Time)
		return nil
	case ContainsAnyTypeBoolean:
		u.Boolean = best.Value.(*bool)
		return nil
	case ContainsAnyTypeStr:
		u.Str = best.Value.(*string)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for ContainsAny", string(data))
}

func (u ContainsAny) MarshalJSON() ([]byte, error) {
	if u.Integer != nil {
		return utils.MarshalJSON(u.Integer, "", true)
	}

	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	if u.DateTime != nil {
		return utils.MarshalJSON(u.DateTime, "", true)
	}

	if u.Boolean != nil {
		return utils.MarshalJSON(u.Boolean, "", true)
	}

	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	return nil, errors.New("could not marshal union type ContainsAny: all fields are null")
}

type StartsWithType string

const (
	StartsWithTypeInteger     StartsWithType = "integer"
	StartsWithTypeNumber      StartsWithType = "number"
	StartsWithTypeDateTime    StartsWithType = "date-time"
	StartsWithTypeBoolean     StartsWithType = "boolean"
	StartsWithTypeStr         StartsWithType = "str"
	StartsWithTypeValueOption StartsWithType = "ValueOption"
)

// StartsWith - Starts with operator - checks if the attribute starts with the value.
type StartsWith struct {
	Integer     *int64       `queryParam:"inline" union:"member"`
	Number      *float64     `queryParam:"inline" union:"member"`
	DateTime    *time.Time   `queryParam:"inline" union:"member"`
	Boolean     *bool        `queryParam:"inline" union:"member"`
	Str         *string      `queryParam:"inline" union:"member"`
	ValueOption *ValueOption `queryParam:"inline" union:"member"`

	Type StartsWithType
}

func CreateStartsWithInteger(integer int64) StartsWith {
	typ := StartsWithTypeInteger

	return StartsWith{
		Integer: &integer,
		Type:    typ,
	}
}

func CreateStartsWithNumber(number float64) StartsWith {
	typ := StartsWithTypeNumber

	return StartsWith{
		Number: &number,
		Type:   typ,
	}
}

func CreateStartsWithDateTime(dateTime time.Time) StartsWith {
	typ := StartsWithTypeDateTime

	return StartsWith{
		DateTime: &dateTime,
		Type:     typ,
	}
}

func CreateStartsWithBoolean(boolean bool) StartsWith {
	typ := StartsWithTypeBoolean

	return StartsWith{
		Boolean: &boolean,
		Type:    typ,
	}
}

func CreateStartsWithStr(str string) StartsWith {
	typ := StartsWithTypeStr

	return StartsWith{
		Str:  &str,
		Type: typ,
	}
}

func CreateStartsWithValueOption(valueOption ValueOption) StartsWith {
	typ := StartsWithTypeValueOption

	return StartsWith{
		ValueOption: &valueOption,
		Type:        typ,
	}
}

func (u *StartsWith) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var integer int64 = int64(0)
	if err := utils.UnmarshalJSON(data, &integer, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  StartsWithTypeInteger,
			Value: &integer,
		})
	}

	var number float64 = float64(0)
	if err := utils.UnmarshalJSON(data, &number, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  StartsWithTypeNumber,
			Value: &number,
		})
	}

	var dateTime time.Time = time.Time{}
	if err := utils.UnmarshalJSON(data, &dateTime, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  StartsWithTypeDateTime,
			Value: &dateTime,
		})
	}

	var boolean bool = false
	if err := utils.UnmarshalJSON(data, &boolean, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  StartsWithTypeBoolean,
			Value: &boolean,
		})
	}

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  StartsWithTypeStr,
			Value: &str,
		})
	}

	var valueOption ValueOption = ValueOption{}
	if err := utils.UnmarshalJSON(data, &valueOption, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  StartsWithTypeValueOption,
			Value: &valueOption,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for StartsWith", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for StartsWith", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(StartsWithType)
	switch best.Type {
	case StartsWithTypeInteger:
		u.Integer = best.Value.(*int64)
		return nil
	case StartsWithTypeNumber:
		u.Number = best.Value.(*float64)
		return nil
	case StartsWithTypeDateTime:
		u.DateTime = best.Value.(*time.Time)
		return nil
	case StartsWithTypeBoolean:
		u.Boolean = best.Value.(*bool)
		return nil
	case StartsWithTypeStr:
		u.Str = best.Value.(*string)
		return nil
	case StartsWithTypeValueOption:
		u.ValueOption = best.Value.(*ValueOption)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for StartsWith", string(data))
}

func (u StartsWith) MarshalJSON() ([]byte, error) {
	if u.Integer != nil {
		return utils.MarshalJSON(u.Integer, "", true)
	}

	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	if u.DateTime != nil {
		return utils.MarshalJSON(u.DateTime, "", true)
	}

	if u.Boolean != nil {
		return utils.MarshalJSON(u.Boolean, "", true)
	}

	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.ValueOption != nil {
		return utils.MarshalJSON(u.ValueOption, "", true)
	}

	return nil, errors.New("could not marshal union type StartsWith: all fields are null")
}

type EndsWithType string

const (
	EndsWithTypeInteger     EndsWithType = "integer"
	EndsWithTypeNumber      EndsWithType = "number"
	EndsWithTypeDateTime    EndsWithType = "date-time"
	EndsWithTypeBoolean     EndsWithType = "boolean"
	EndsWithTypeStr         EndsWithType = "str"
	EndsWithTypeValueOption EndsWithType = "ValueOption"
)

// EndsWith - Ends with operator - checks if the attribute ends with the value.
type EndsWith struct {
	Integer     *int64       `queryParam:"inline" union:"member"`
	Number      *float64     `queryParam:"inline" union:"member"`
	DateTime    *time.Time   `queryParam:"inline" union:"member"`
	Boolean     *bool        `queryParam:"inline" union:"member"`
	Str         *string      `queryParam:"inline" union:"member"`
	ValueOption *ValueOption `queryParam:"inline" union:"member"`

	Type EndsWithType
}

func CreateEndsWithInteger(integer int64) EndsWith {
	typ := EndsWithTypeInteger

	return EndsWith{
		Integer: &integer,
		Type:    typ,
	}
}

func CreateEndsWithNumber(number float64) EndsWith {
	typ := EndsWithTypeNumber

	return EndsWith{
		Number: &number,
		Type:   typ,
	}
}

func CreateEndsWithDateTime(dateTime time.Time) EndsWith {
	typ := EndsWithTypeDateTime

	return EndsWith{
		DateTime: &dateTime,
		Type:     typ,
	}
}

func CreateEndsWithBoolean(boolean bool) EndsWith {
	typ := EndsWithTypeBoolean

	return EndsWith{
		Boolean: &boolean,
		Type:    typ,
	}
}

func CreateEndsWithStr(str string) EndsWith {
	typ := EndsWithTypeStr

	return EndsWith{
		Str:  &str,
		Type: typ,
	}
}

func CreateEndsWithValueOption(valueOption ValueOption) EndsWith {
	typ := EndsWithTypeValueOption

	return EndsWith{
		ValueOption: &valueOption,
		Type:        typ,
	}
}

func (u *EndsWith) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var integer int64 = int64(0)
	if err := utils.UnmarshalJSON(data, &integer, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  EndsWithTypeInteger,
			Value: &integer,
		})
	}

	var number float64 = float64(0)
	if err := utils.UnmarshalJSON(data, &number, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  EndsWithTypeNumber,
			Value: &number,
		})
	}

	var dateTime time.Time = time.Time{}
	if err := utils.UnmarshalJSON(data, &dateTime, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  EndsWithTypeDateTime,
			Value: &dateTime,
		})
	}

	var boolean bool = false
	if err := utils.UnmarshalJSON(data, &boolean, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  EndsWithTypeBoolean,
			Value: &boolean,
		})
	}

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  EndsWithTypeStr,
			Value: &str,
		})
	}

	var valueOption ValueOption = ValueOption{}
	if err := utils.UnmarshalJSON(data, &valueOption, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  EndsWithTypeValueOption,
			Value: &valueOption,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for EndsWith", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for EndsWith", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(EndsWithType)
	switch best.Type {
	case EndsWithTypeInteger:
		u.Integer = best.Value.(*int64)
		return nil
	case EndsWithTypeNumber:
		u.Number = best.Value.(*float64)
		return nil
	case EndsWithTypeDateTime:
		u.DateTime = best.Value.(*time.Time)
		return nil
	case EndsWithTypeBoolean:
		u.Boolean = best.Value.(*bool)
		return nil
	case EndsWithTypeStr:
		u.Str = best.Value.(*string)
		return nil
	case EndsWithTypeValueOption:
		u.ValueOption = best.Value.(*ValueOption)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for EndsWith", string(data))
}

func (u EndsWith) MarshalJSON() ([]byte, error) {
	if u.Integer != nil {
		return utils.MarshalJSON(u.Integer, "", true)
	}

	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	if u.DateTime != nil {
		return utils.MarshalJSON(u.DateTime, "", true)
	}

	if u.Boolean != nil {
		return utils.MarshalJSON(u.Boolean, "", true)
	}

	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.ValueOption != nil {
		return utils.MarshalJSON(u.ValueOption, "", true)
	}

	return nil, errors.New("could not marshal union type EndsWith: all fields are null")
}

// Condition - Pydantic model describing a Lumos Condition shape.
//
// This model may be used to validate any input Condition JSON across services that expose
//
//	interacting with LumosConditions in some manner.
type Condition struct {
	// Attribute operator. This operator specifies an attribute of one of the target entities in our evaluation context that we'd like to use in this condition.
	Attribute *Attribute `json:"attribute,omitempty"`
	// Equality operator.
	Equals *Equals `json:"equals,omitempty"`
	// Not equal to operator.
	NotEqual *NotEqual `json:"!=,omitempty"`
	// AND operator - composes multiple conditions.
	And []Condition `json:"and,omitempty"`
	// OR operator - composes multiple conditions.
	Or []Condition `json:"or,omitempty"`
	// NOT operator - negates a condition.
	Not *Condition `json:"not,omitempty"`
	// IN operator - checks if the attribute is in the list. When applied to a string, checks if the value on the left-hand-side of the condition is a substring of this value.
	In *In `json:"in,omitempty"`
	// Exists operator - checks if the attribute exists.
	Exists *bool `json:"exists,omitempty"`
	// Greater than operator.
	GreaterThan *GreaterThan `json:">,omitempty"`
	// Greater than or equal to operator.
	GreaterThanEqual *GreaterThanEqual `json:">=,omitempty"`
	// Less than operator.
	LessThan *LessThan `json:"<,omitempty"`
	// Less than or equal to operator.
	LessThanEqual *LessThanEqual `json:"<=,omitempty"`
	// Contains operator - checks if the attribute contains the value.
	Contains *Contains `json:"contains,omitempty"`
	// CONTAINS ANY operator - checks if the attribute contains any of the values. In general, this operator is expected to operate against 2 different collections
	ContainsAny []ContainsAny `json:"contains_any,omitempty"`
	// Starts with operator - checks if the attribute starts with the value.
	StartsWith *StartsWith `json:"starts_with,omitempty"`
	// Ends with operator - checks if the attribute ends with the value.
	EndsWith *EndsWith `json:"ends_with,omitempty"`
	// Lumos expression operator - evaluates a Lumos expression.
	LumosExpression *string `json:"lumos_expression,omitempty"`
}

func (c Condition) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *Condition) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (c *Condition) GetAttribute() *Attribute {
	if c == nil {
		return nil
	}
	return c.Attribute
}

func (c *Condition) GetEquals() *Equals {
	if c == nil {
		return nil
	}
	return c.Equals
}

func (c *Condition) GetNotEqual() *NotEqual {
	if c == nil {
		return nil
	}
	return c.NotEqual
}

func (c *Condition) GetAnd() []Condition {
	if c == nil {
		return nil
	}
	return c.And
}

func (c *Condition) GetOr() []Condition {
	if c == nil {
		return nil
	}
	return c.Or
}

func (c *Condition) GetNot() *Condition {
	if c == nil {
		return nil
	}
	return c.Not
}

func (c *Condition) GetIn() *In {
	if c == nil {
		return nil
	}
	return c.In
}

func (c *Condition) GetExists() *bool {
	if c == nil {
		return nil
	}
	return c.Exists
}

func (c *Condition) GetGreaterThan() *GreaterThan {
	if c == nil {
		return nil
	}
	return c.GreaterThan
}

func (c *Condition) GetGreaterThanEqual() *GreaterThanEqual {
	if c == nil {
		return nil
	}
	return c.GreaterThanEqual
}

func (c *Condition) GetLessThan() *LessThan {
	if c == nil {
		return nil
	}
	return c.LessThan
}

func (c *Condition) GetLessThanEqual() *LessThanEqual {
	if c == nil {
		return nil
	}
	return c.LessThanEqual
}

func (c *Condition) GetContains() *Contains {
	if c == nil {
		return nil
	}
	return c.Contains
}

func (c *Condition) GetContainsAny() []ContainsAny {
	if c == nil {
		return nil
	}
	return c.ContainsAny
}

func (c *Condition) GetStartsWith() *StartsWith {
	if c == nil {
		return nil
	}
	return c.StartsWith
}

func (c *Condition) GetEndsWith() *EndsWith {
	if c == nil {
		return nil
	}
	return c.EndsWith
}

func (c *Condition) GetLumosExpression() *string {
	if c == nil {
		return nil
	}
	return c.LumosExpression
}
